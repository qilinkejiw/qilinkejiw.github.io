{"meta":{"title":"����Ƽ�","subtitle":"","description":"","author":"Mr.wang","url":"http://example.com"},"pages":[],"posts":[{"title":"设置字节对齐","slug":"language_c_cpp_keyword_sizeof_3","date":"2021-03-23T23:15:54.507Z","updated":"2021-03-23T23:29:20.825Z","comments":true,"path":"2021/03/24/language_c_cpp_keyword_sizeof_3/","link":"","permalink":"http://example.com/2021/03/24/language_c_cpp_keyword_sizeof_3/","excerpt":"","text":"在C语言中，结构是一种复合数据类型，其构成元素既能够是基本数据类型（如int、long、float等）的变量，也能够是一些复合数据类型（如数组、结构、联合等）的数据单元。linux在结构中，编译器为结构的每一个成员按其天然对界（alignment）条件分配空间。各个成员按照它们被声明的顺序在内存中顺序存储，第一个成员的地址和整个结构的地址相同。编程 例如，下面的结构各成员空间分配状况： struct test { char x1; short x2; float x3; char x4; }; 结构的第一个成员x1，其偏移地址为0，占据了第1个字节。 第二个成员x2为short类型，其起始地址必须2字节对界，所以，编译器在x2和x1之间填充了一个空字节。 第三个成员x3和第四个成员x4刚好落在其天然对界地址上，在它们前面不须要额外的填充字节。 在test结构中，成员x3要求4字节对界，是该结构全部成员中要求的最大对界单元，于是test结构的天然对界条件为4字节，编译器在成员x4后面填充了3个空字节。整个结构所占据空间为12字节。数组更改C编译器的缺省字节对齐方式在缺省状况下，C编译器为每个变量或是数据单元按其天然对界条件分配空间。通常地，能够经过下面的方法来改变缺省的对界条件：网络方式一： · 使用伪指令#pragma pack (n)，C编译器将按照n个字节对齐。 · 使用伪指令#pragma pack ()，取消自定义字节对齐方式。优化方式二： · __attribute((aligned (n)))，让所做用的结构成员对齐在n字节天然边界上。若是结构中有成员的长度大于n，则按照最大成员的长度来对齐。 · attribute ((packed))，取消结构在编译过程当中的优化对齐，按照实际占用字节数进行对齐。spa以上的n = 1, 2, 4, 8, 16… 第一种方式较为常见。操作系统在网络协议编程中，常常会处理不一样协议的数据报文。一种方法是经过指针偏移的方法来获得各类信息，但这样作不只编程复杂，并且一旦协议有变化，程序修改起来也比较麻烦。在了解了编译器对结构空间的分配原则以后，咱们彻底能够利用这一特性定义本身的协议结构，经过访问结构的成员来获取各类信息。这样作，不只简化了编程，并且即便协议发生变化，咱们也只需修改协议结构的定义便可，其它程序无需修改，省时省力。下面以TCP协议首部为例，说明如何定义协议结构。其协议结构定义以下：指针#pragma pack(1) // 按照1字节方式进行对齐code对齐原则:一、基本类型变量起始地址要按必定规则对齐. char 类型,其起始地址要1字节边界上,即其地址能被1整除(即任意地址便可) short类型,其起始地址要2字节边界上,即其地址能被2整除 int 类型,其起始地址要4字节边界上,即其地址能被4整除 long类型,其起始地址要4字节边界上,即其地址能被4整除 float类型,其起始地址要4字节边界上,即其地址能被4整除 double类型,其起始地址要8字节边界上,即其地址能被8整除 blog 注意：指针类型，其起始地址要在8字节边界上二、结构实例起始址要在本身最大尺寸成员的对齐地址上 如最大尺寸的成员是short,则要基于2对齐三、结构内成员的偏移量也要参照第1条,知足相应倍数 如成员是short,则偏移量也是2的倍数. 这一条实际仍然是第1条规则的扩展,由于结构起始地址按最大倍数来,加上内部相应倍数,这样成员绝对地址仍然知足第1条规定四、结构总尺寸也要对齐. 要为最大尺寸的成员的整数倍,若是不是则要在结构最后补齐成整数倍字节对齐实例#include &lt;stdio.h&gt; // 使用系统默认的字节对齐方式，32位机器通常为4字节对齐；struct person0{ char *name; int age; char score; int id;}; // 取消在编译过程当中的优化对齐，按照实际占用字节数进行对齐struct person1{ char *name; int age; char score; int id;}attribute((packed)); // 构体成员对齐在4字节边界上struct person2{ char *name; int age; char score; int id;} attribute((aligned (4))); int main(int argc, char **argv){ printf(“size of (struct person0) = %lu.\\n”, sizeof(struct person0)); printf(“size of (struct person1) = %lu.\\n”, sizeof(struct person1)); printf(“size of (struct person2) = %lu.\\n”, sizeof(struct person2)); return 0; }运行结果：因64位系统，因此指针占8字节的数据内存，int 也是8字节； getconf命令能够获取系统的基本配置信息，好比操做系统位数,内存大小查看操做系统是多少位 转载https://www.shangmayuan.com/a/2c6ca5ec3d724f059fe45fd7.html","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"内存对齐","slug":"language_c_cpp_keyword_sizeof_2","date":"2021-03-17T13:52:29.627Z","updated":"2021-03-23T23:24:26.874Z","comments":true,"path":"2021/03/17/language_c_cpp_keyword_sizeof_2/","link":"","permalink":"http://example.com/2021/03/17/language_c_cpp_keyword_sizeof_2/","excerpt":"","text":"内存对齐 在我们的程序中，数据结构还有变量等等都需要占有内存，在很多系统中，它都要求内存分配的时候要对齐，这样做的好处就是可以提高访问内存的速度。 原则结构体的大小等于结构体内最大成员大小的整数倍结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍为了满足规则1和2编译器会在结构体成员之后进行字节填充 我们还是先来看一段简单的程序： 程序一 1 #include 2 using namespace std; 3 4 struct X1 5 { 6 int i;//4个字节 7 char c1;//1个字节 8 char c2;//1个字节 9 };1011 struct X212 {13 char c1;//1个字节14 int i;//4个字节15 char c2;//1个字节16 };1718 struct X319 {20 char c1;//1个字节21 char c2;//1个字节22 int i;//4个字节23 };24 int main()25 {26 cout&lt;&lt;”long “&lt;&lt;sizeof(long)&lt;&lt;”\\n”;27 cout&lt;&lt;”float “&lt;&lt;sizeof(float)&lt;&lt;”\\n”;28 cout&lt;&lt;”int “&lt;&lt;sizeof(int)&lt;&lt;”\\n”;29 cout&lt;&lt;”char “&lt;&lt;sizeof(char)&lt;&lt;”\\n”;3031 X1 x1;32 X2 x2;33 X3 x3;34 cout&lt;&lt;”x1 的大小 “&lt;&lt;sizeof(x1)&lt;&lt;”\\n”;35 cout&lt;&lt;”x2 的大小 “&lt;&lt;sizeof(x2)&lt;&lt;”\\n”;36 cout&lt;&lt;”x3 的大小 “&lt;&lt;sizeof(x3)&lt;&lt;”\\n”;37 return 0;38 } 这段程序的功能很简单，就是定义了三个结构X1,X2,X3,这三个结构的主要区别就是内存数据摆放的顺序，其他都是一样的，另外程序输入了几种基本类型所占用的字节数，以及我们这里的三个结构所占用的字节数。 这段程序的运行结果为： 1 long 42 float 43 int 44 char 15 x1 的大小 86 x2 的大小 127 x3 的大小 8 结果的前面四行没有什么问题，但是我们在最后三行就可以看到三个结构占用的空间大小不一样，造成这个原因就是内部数据的摆放顺序，怎么会这样呢？ 下面就是我们需要讲的内存对齐了。 内存是一个连续的块，我们可以用下面的图来表示, 它是以4个字节对一个对齐单位的： 图一 让我们看看三个结构在内存中的布局： 首先是 X1，如下图所示 X1 中第一个是 Int类型，它占有4字节，所以前面4格就是满了，然后第二个是char类型，这中类型只占一个字节，所以它占有了第二个4字节组块中的第一格，第三个也是char类型，所以它也占用一个字节，它就排在了第二个组块的第二格，因为它们加在一起大小也不超过一个块，所以他们三个变量在内存中的结构就是这样的，因为有内存分块对齐，所以最后出来的结果是8，而不是6，因为后面两个格子其实也算是被用了。 再次看看X2，如图所示 X2中第一个类型是Char类型，它占用一个字节，所以它首先排在第一组块的第一个格子里面，第二个是Int类型，它占用4个字节，第一组块已经用掉一格，还剩3格，肯定是无法放下第二Int类型的，因为要考虑到对齐，所以不得不把它放到第二个组块，第三个类型是Char类型，跟第一个类似。所因为有内存分块对齐，我们的内存就不是8个格子了，而是12个了。 再看看X3，如下图所示： 关于X3的说明其实跟X1是类似的，只不过它把两个1个字节的放到了前面，相信看了前面两种情况的说明这里也是很容易理解的。 含有其他类时： 分析各个成员长度(包括其他类成员的长度)；其他类成员的长度不会随着位置的变化而变化；找出各个成员的长度最大值（包含其他类和结构体的成员）；若长度最大成员在为结构体的成员中，则按结构体成员为分界点分界；其他成员中有最大长度的成员，则该成员为分界点；求出各段长度，求出大于该和的最小M的整数倍即为该部分长度class A{ char a; double b; int c;};//sizeof(A)为24Bclass C{ char a; A obj; int b; double c;};//a、b、obj、c的长度分别为1、24、4、8；最长的成员为8，所以以obj和c为界。//每部分都取大于各部分和的8的最小倍数。sizeof(C)=8+24+8+8=48B 空结构体和空类型空结构体和空类型的大小计算。含有虚函数的类的大小计算。 sizeof(空类)和sizeof(空结构体)的大小都为1 static的结构体有static的结构体 struct S4{ char a; long b; static long c; //静态 };静态变量存放在全局数据区内，而sizeof计算栈中分配的空间的大小，故不计算在内，S4的大小为4+4=8。#pragma pack（n）指令设置1.2.4对齐。linux下最高位4.#pragma pack（）指令默认为四。 unionunion的长度取决于其中的长度最大的那个成员变量的长度。即union中成员变量是重叠摆放的，其开始地址相同。其实union(共用体)的各个成员是以同一个地址开始存放的,每一个时刻只可以存储一个成员,这样就要求它在分配内存单元时候要满足两点: 1.一般而言,共用体类型实际占用存储空间为其最长的成员所占的存储空间； 2.若是该最长的存储空间对其他成员的元类型(如果是数组,取其类型的数据长度,例int a[5]为4)不满足整除关系,该最大空间自动延伸; 我们来看看这段代码:union mm{ char a;//元长度1 int b[5];//元长度4 double c;//元长度8 int d[3]; };本来mm的空间应该是sizeof(int)*5=20;但是如果只是20个单元的话,那可以存几个double型(8位)呢?两个半?当然不可以,所以mm的空间延伸为既要大于20,又要满足其他成员所需空间的整数倍,即24所以union的存储空间先看它的成员中哪个占的空间最大,拿他与其他成员的元长度比较,如果可以整除就行。 参考材料http://www.cppblog.com/cc/archive/2011/08/28/10765.htmlhttps://blog.csdn.net/so_geili/article/details/53014722","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"函数","slug":"language_c_cpp_f_1_c","date":"2021-03-17T01:17:54.001Z","updated":"2021-03-17T01:17:54.001Z","comments":true,"path":"2021/03/17/language_c_cpp_f_1_c/","link":"","permalink":"http://example.com/2021/03/17/language_c_cpp_f_1_c/","excerpt":"","text":"","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"按位指定结构体中变量的大小","slug":"language_c_cpp_skills_bit_2","date":"2021-03-17T01:16:54.603Z","updated":"2021-03-17T01:22:33.392Z","comments":true,"path":"2021/03/17/language_c_cpp_skills_bit_2/","link":"","permalink":"http://example.com/2021/03/17/language_c_cpp_skills_bit_2/","excerpt":"","text":"在大多数情况下，我们一般这样定义结构体：struct student{unsigned int sex;unsigned int age;};对于一般的应用，这已经能很充分地实现数据了的 “ 封装 ” 。但是，在实际工程中，往往碰到这样的情况：那就是要用一个基本类型变量中的不同的位表示不同的含义。譬如一个 cpu 内部的标志寄存器，假设为 16 bit ，而每个 bit 都可以表达不同的含义，有的表示结果是否为 0 ，有的表示是否越界等等。这个时候我们用什么数据结构来表达这个寄存器呢？答案还是结构体！为达到此目的，我们要用到结构体的高级特性，那就是在基本成员变量的后面添加“ : 数据位数”组成新的结构体：struct xxx{成员 1 类型成员 1 : 成员 1 位数 ;成员 2 类型成员 2 : 成员 2 位数 ;成员 3 类型成员 3 : 成员 3 位数 ;};基本的成员变量就会被拆分！这个语法在初级编程中很少用到，但是在高级程序设计中不断地被用到！例如：struct student{unsigned int sex : 1;unsigned int age : 15;};上述结构体中的两个成员 sex 和 age 加起来只占用了一个 unsigned int 的空间（假设 unsigned int 为 16 位）。基本成员变量被拆分后，访问的方法仍然和访问没有拆分的情况是一样的，例如：struct student sweek;sweek.sex = MALE;// 这里的 MALE 只能是 0 或 1 ，值不能大于 1sweek.age = 20;虽然拆分基本成员变量在语法上是得到支持的，但是并不等于我们想怎么分就怎么分，例如下面的拆分显然是不合理的：struct student{unsigned int sex : 1;unsigned int age : 12;};这是因为 1+12 = 13 ，不能再组合成一个基本成员，不能组合成 char 、 int 或任何类型，这显然是不能 “ 自圆其说 ” 的。在拆分基本成员变量的情况下，我们要特别注意数据的存放顺序，这还与 CPU 是 Big endian 还是 Little endian 来决定。 Little endian 和 Big endian 是 CPU 存放数据的两种不同顺序。对于整型、长整型等数据类型， Big endian 认为第一个字节是最高位字节（按照从低地址到高地址的顺序存放数据的高位字节到低位字节）；而 Little endian 则相反，它认为第一个字节是最低位字节（按照从低地址到高地址的顺序存放数据的低位字节到高位字节）。我们定义 IP 包头结构体为：struct iphdr {#if defined(__LITTLE_ENDIAN_BITFIELD)__u8 ihl:4,version:4;#elif defined (__BIG_ENDIAN_BITFIELD)__u8 version:4,ihl:4;#else#error “Please fix &lt;asm/byteorder.h&gt;”#endif__u8 tos;__u16 tot_len;__u16 id;__u16 frag_off;__u8 ttl;__u8 protocol;__u16 check;__u32 saddr;__u32 daddr;/*The options start here. */};在 Little endian 模式下， iphdr 中定义：__u8 ihl:4,version:4;其存放方式为：第 1 字节低 4 位 ihl第 1 字节高 4 位 version （ IP 的版本号）若在 Big endian 模式下还这样定义，则存放方式为：第 1 字节低 4 位 version （ IP 的版本号）第 1 字节高 4 位 ihl这与实际的 IP 协议是不匹配的，所以在 Linux 内核源代码中， IP 包头结构体的定义利用了宏：#if defined(__LITTLE_ENDIAN_BITFIELD)…#elif defined (__BIG_ENDIAN_BITFIELD)…#endif来区分两种不同的情况。由此我们总结全文的主要观点：（ 1 ） C/C++ 语言的结构体支持对其中的基本成员变量按位拆分；（ 2 ） 拆分的位数应该是合乎逻辑的，应仍然可以组合为基本成员变量；要特别注意拆分后的数据的存放顺序，这一点要结合具体的 CPU 的结构。该文是由宋宝华处转载而来的，笔者以前从未知道结构体还可以这样用法，笔者做过尝试，再 VC 下用过的感受有两点1、 结构体按位拆分时，虽然宋兄提醒不能拆分如文中红色背景显示的情况，但是本人试过，并非是不可以的，而且如果 CPU 支持 32 的话，显然文中的以 16 位来分配的话也是没有达到要求的。2、 按位拆分时字节数目问题，我们先看两例struct student1{unsigned char sex : 1;unsigned int no : 5;char age : 7;int grade : 10;};struct student2{unsigned char sex : 1;char age : 7;unsigned int no : 5;int grade : 10;};以上两例中虽然意思并不大，但是如果按 int 为 2 字节 16 位 char 为 1 字节 8 位来划分内存的话，那么 student1 占用了 6 字节共 48 位，但是实际使用了 23 位，另外 25 位没定义，而 student2 占用了 3 字节共 24 位，但是实际使用也是 23 位。这个过程，我把它总结为前后变量的类型不一致时，字节就重新分配。3、 赋值过程中数据编码问题。还看两例student1 ss;ss.age = 255;student2 st;st.age= 191;ss.age 的值为 -1 ，而 st.age 的值为 63 ，其实 255 为 11111111 ，因为是 7 位，所以采用截断方式，变成 1111111 ，又因为 age 是有符号的变量，所以根据负数的编码规则赋值 255 时得到的结果就是 -1 。在这里采用了截断的方式，为止正确赋值时一定不能大于位数编码值。 源文档 http://blog.csdn.net/sgdgoodboy/article/details/2020244","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}]},{"title":"函数","slug":"language_c_cpp_function_1_c","date":"2021-03-17T00:55:39.668Z","updated":"2021-03-17T00:56:42.460Z","comments":true,"path":"2021/03/17/language_c_cpp_function_1_c/","link":"","permalink":"http://example.com/2021/03/17/language_c_cpp_function_1_c/","excerpt":"","text":"","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"c，c++数值取值范围","slug":"language_c_cpp_skills_union_c","date":"2021-03-17T00:47:39.555Z","updated":"2021-03-15T23:41:28.828Z","comments":true,"path":"2021/03/17/language_c_cpp_skills_union_c/","link":"","permalink":"http://example.com/2021/03/17/language_c_cpp_skills_union_c/","excerpt":"","text":"unsigned int 0～4294967295 int 2147483648～2147483647 unsigned long 0～4294967295 long 2147483648～2147483647 long long的最大值：9223372036854775807 long long的最小值：-9223372036854775808 unsigned long long的最大值：1844674407370955161 __int64的最大值：9223372036854775807 __int64的最小值：-9223372036854775808 unsigned __int64的最大值：18446744073709551615","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"c，c++数值取值范围","slug":"language_c_cpp_common_range","date":"2021-03-15T23:38:58.505Z","updated":"2021-03-15T23:41:28.828Z","comments":true,"path":"2021/03/16/language_c_cpp_common_range/","link":"","permalink":"http://example.com/2021/03/16/language_c_cpp_common_range/","excerpt":"","text":"unsigned int 0～4294967295 int 2147483648～2147483647 unsigned long 0～4294967295 long 2147483648～2147483647 long long的最大值：9223372036854775807 long long的最小值：-9223372036854775808 unsigned long long的最大值：1844674407370955161 __int64的最大值：9223372036854775807 __int64的最小值：-9223372036854775808 unsigned __int64的最大值：18446744073709551615","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"c++强制类型转换","slug":"language_c_cpp_keyword_convert","date":"2021-03-15T14:17:14.269Z","updated":"2021-03-24T13:11:42.272Z","comments":true,"path":"2021/03/15/language_c_cpp_keyword_convert/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_keyword_convert/","excerpt":"","text":"类型转换操作符:static_cast, dynamic_cast, const_cast, reinterpret_cast. 呵呵，今天来好好看看着几个转换操作符的用法。以前老是看着眼熟，但是用着手生。今天决定搞定这些个东西。在C语言中类型转换有几种方式： (expression). 在表达式外边加括号，由编译器来决定怎么改变。 new_type(expression）. 强制类型括号住表达式。 (new_type)expression. 括号住强制类型。 C语言允许的内置转换。 这些转换非常高效，我非常喜欢使用。特别是在指针转换和数值转换时用到的非常多。只要编写程序的人知道自己要做什么转换，并知道应该怎样转换的话，我认为上边的转换方式非常之好。但是没有清楚的了解每个转换的细节的话，就有可能出现问题，比如指针指向不应该指向的区域：出现野指针或者指向位置错误（主要是对内存结构不了解），或者计算数值被截去等问题发生。C++程序兼容C语言的转化，但是针对面向对象语言的特性，设计了以下几个类型转换操作符。他们的出现是为了C语言类型转换中语义模糊和固有的危险陷阱，因为C语言不去判断所要操作的类型转换是否合理。static_cast:用于非多态类型的转换。dynamic_cast:用于多态类型的转换。const_cast:用来消除const, volatile, __unaligned属性的转换。reinterpret_cast:用于空间的重新解释。还有一个在VS2005中出现的类型转换关键字safe_cast.#2 static_cast:static_cast(expression)用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。把空指针转换成目标类型的空指针。把任何类型的表达式转换成void类型。注意：static_cast不能转换掉expression的const、volitale、或者__unaligned属性。enum e { A = 1, B, C };double d = 12.25;unsigned int ui = 25;char c = static_cast(ui);int i = static_cast(d);int j = static_cast(B);//父类子类转换class F //father{public: int _father;};class S : public F //son{public: _son;};F *pFather = new F();S *pSon = new S();F *pF;S *pS;pF = static_cast&lt;F *&gt;(pSon); //将子类指针转换为父类指针，OKpS = static_cast&lt;S *&gt;(pFather); //将父类指针转换为子类指针，错误第二个错误的转换不是说编译器编译不过去，而是运行时会出现错误。原因如下：假设pF指向了pSon的位置，它可以访问_father，它找不到_son，这样没有问题。但是pS指向了pFather的位置，它访问_father没有问题，但是访问_son时就会产生错误，因为pFather根本没有_son这个变量。下面是将父类转换为子类指针时，static_cast和dymanic_cast两者不同的表现：class F{public: virtual void speak(){}; int i;}; class S : public F{public: void speak() { cout &lt;&lt; “S = “ &lt;&lt; _s &lt;&lt; endl; } double _s;};F *pF = new F();S *pS = static_cast&lt;S*&gt;(pF);pS-&gt;speak();S1 *pDS = dynamic_cast&lt;S*&gt;(pF);pDS-&gt;speak();静态的转换编译不显示警告，运行结果不输出(调用F的speak函数)。动态的转换编译显示可能出现不可预期的结果，运行时崩溃。（VS2005时，返回空指针，但是不会崩溃。我认为要是按照C++的特性还是崩溃比较好一点，让程序员容易理解这么做是错误的。） dynamic_cast:dynamic_cast(expression)该运算符把expression转换成type-id类型的对象。Type-id必须是类的指针、类的引用或者void *；如果type-id是类指针类型，那么expression也必须是一个指针，如果type-id是一个引用，那么expression也必须是一个引用。 dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。 在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。 dynamic_cast 判定转换是否成功if (!dynamic_cast&lt;MapContext*&gt;(context)-&gt;GetInputType().empty()) {} class B{public: int m_iNum; virtual void foo(); }; class D:public B{ public: char *m_szName[100];}; void func(B *pb){ D *pd1 = static_cast&lt;D *&gt;(pb); D *pd2 = dynamic_cast&lt;D *&gt;(pb);} 在上面的代码段中，如果pb指向一个D类型的对象，pd1和pd2是一样的，并且对这两个指针执行D类型的任何操作都是安全的；但是，如果pb指向的是一个B类型的对象，那么pd1将是一个指向该对象的指针，对它进行D类型的操作将是不安全的（如访问m_szName），而pd2将是一个空指针。另外要注意：B要有虚函数，否则会编译出错；static_cast则没有这个限制。这是由于运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表（关于虚函数表的概念，详细可见&lt;Inside c++ object model&gt;）中，只有定义了虚函数的类才有虚函数表，没有定义虚函数的类是没有虚函数表的。 另外，dynamic_cast还支持交叉转换（cross cast）。如下代码所示。 class A{public: int m_iNum; virtual void f(){} }; class B:public A{}; class D:public A{}; void foo(){ B *pb = new B; pb-&gt;m_iNum = 100; D *pd1 = static_cast&lt;D *&gt;(pb); //copile error D *pd2 = dynamic_cast&lt;D *&gt;(pb); //pd2 is NULL delete pb; } 在函数foo中，使用 static_cast 进行转换是不被允许的，将在编译时出错；而使用 dynamic_cast 的转换则是允许的，结果是空指针。 1．最常用的用法就是将子类指针转换为父类指针。（不举例）2．当type_id为void*时，指针指向整个对象的空间。Class A;A *pA = new A();void p = dynamic_cast&lt;void*&gt;(pA);但是type_id不为void时，计算机就要在运行时检查是否能够转换。3．跳级转换。class A{};class B : public A{};class C : public B{}; A *pA; B *pB; C *pC = new C(); pB = dynamic_cast&lt;B*&gt;(pD); //逐级转换OK pA = dynamic_cast&lt;A*&gt;(pB); //逐级转换OK 或者 pA = dynamic_cast&lt;A*&gt;(pC); //跳级转换OK delete pD;以下情况跳级转换不可以：class A{};class B : public A{};class C : public A{};class D : public B, public C{}; A *pA; D *pD = new D(); pA = dynamic_cast&lt;A*&gt;(pB); //出现错误，是不行的，原因大家都清楚。 class A{};class B : public A{};class C : public A{};class D : public B{};class E : public C, public D{}; A *pA; B pB; E pE = new E(); pB = dynamic_cast&lt;B*&gt;(pE); pA = dynamic_cast&lt;A*&gt;(pB); //可以 pA = dynamic_cast&lt;A*&gt;(pE); //不可以，原因是很简单的。 delete pE;4．两个不相干的类之间转换。class A {};class B {}; A pa = new A; B pb = dynamic_cast&lt;B*&gt;(pa); // 不可以，没有相互转换的基础但是reinterpret_cast可以转换，可以参考reinterpret_cast const_cast:const_cast(expression)这个关键字消除了几个关键字的作用const, volatile,和__unaligned的作用。const经常使用。MSDN有const的例子照抄过来。class CCTest {public: void setNumber( int ); void printNumber() const;private: int number;};void CCTest::setNumber( int num ) { number = num; }void CCTest::printNumber() const { cout &lt;&lt; “/nBefore: “ &lt;&lt; number; const_cast&lt; CCTest * &gt;( this )-&gt;number–;//这里消除了const的作用 cout &lt;&lt; “/nAfter: “ &lt;&lt; number;}int main() { CCTest X; X.setNumber( 8 ); X.printNumber();} reinterpret_cast:reinterpret_cast这个关键字比较“强悍”，随意转换类型。但是转换错误，就是你的不对了。呵呵，我的原则两个字：“慎用”。这个关键字可以在任何类型的指针之间转换。不可以替代const_cast。不提供安全转换。MSDN的例子显示出来它的强悍，也显示出了他的脆弱。只要你一个不小心就会乱用。#include // Returns a hash code based on an addressunsigned short Hash( void *p ) { unsigned int val = reinterpret_cast( p ); return ( unsigned short )( val ^ (val &gt;&gt; 16));} using namespace std;int main() { int a[20]; for ( int i = 0; i &lt; 20; i++ ) cout &lt;&lt; Hash( a + i ) &lt;&lt; endl;} 参考文档http://blog.csdn.net/callmeback/article/details/4040583https://blog.csdn.net/bboyfeiyu/article/details/9057447https://stackoverflow.com/questions/2473628/c-cant-static-cast-from-double-to-int","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"volatile 关键字详解","slug":"language_c_cpp_keyword_volatile_c","date":"2021-03-15T14:15:54.572Z","updated":"2021-03-17T00:15:34.164Z","comments":true,"path":"2021/03/15/language_c_cpp_keyword_volatile_c/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_keyword_volatile_c/","excerpt":"","text":"最近在讨论多线程编程中的一个可能的 false sharing 问题时，有人提出加 volatile 可能可以解决问题。这种错误的认识荼毒多年，促使我写下这篇文章。 约定Volatile 这个话题，涉及到计算机科学多个领域多个层次的诸多细节。仅靠一篇博客，很难穷尽这些细节。因此，若不对讨论范围做一些约定，很容易就有诸多漏洞。到时误人子弟，就不好了。以下是一些基本的约定： 这篇博文讨论的 volatile 关键字，是 C 和 C++ 语言中的关键字。Java 等语言中，也有 volatile 关键字。但它们和 C/C++ 里的 volatile 不完全相同，不在这篇博文的讨论范围内。这篇博文讨论的 volatile 关键字，是限定在 C/C++ 标准之下的。这也就是说，我们讨论的内容应该是与平台无关的，同时也是与编译器扩展无关的。相应的，这篇文章讨论的「标准」指的是 C/C++ 的标准，而不是其他什么东西。我们希望编写的代码是 (1) 符合标准的，(2) 性能良好的，(3) 可移植的。这里 (1) 保证了代码执行结果的正确性，(2) 保证了高效性，(3) 体现了平台无关性（以及编译器扩展等的无关性）。含义单词 volatile 的含义在谈及 C/C++ 中的 volatile 关键字时，总有人会拿 volatile 这个英文单词的中文解释说事。他们把 volatile 翻译作「易变的」。但事实上，对于翻译来说，很多时候目标语言很难找到一个词能够反映源语言中单词的全部含义和细节。此处「易变的」就无法做到这一点。 Volatile 的意思，若要详细理解，还是应该查阅权威的英英字典。在柯林斯高阶学习词典中，volatile 是这样解释的： A situation that is volatile is likely to change suddenly and unexpectedly.这里对 volatile 的解释有三个精髓的形容词和副词，体现了 volatile 的含义。 likely：可能的。这意味着被 volatile 形容的对象「有可能也有可能不」发生改变，因此我们不能对这样的对象的状态做出任何假设。suddenly：突然地。这意味着被 volatile 形容的对象可能发生瞬时改变。unexpectedly：不可预期地。这与 likely 相互呼应，意味着被 volatile 形容的对象可能以各种不可预期的方式和时间发生更改。因此，volatile 其实就是告诉我们，被它修饰的对象出现任何情况都不要奇怪，我们不能对它们做任何假设。 程序中 volatile 的含义对于程序员来说，程序本身的任何行为都必须是可预期的。那么，在程序当中，什么才叫 volatile 呢？这个问题的答案也很简单：程序可能受到程序之外的因素影响。 考虑以下 C/C++ 代码。 volatile int p = / … */;int a, b;a = *p;b = *p;若忽略 volatile，那么 p 就只是一个「指向 int 类型的指针」。这样一来，a = *p; 和 b = *p; 两句，就只需要从内存中读取一次就够了。因为从内存中读取一次之后，CPU 的寄存器中就已经有了这个值；把这个值直接复用就可以了。这样一来，编译器就会做优化，把两次访存的操作优化成一次。这样做是基于一个假设：我们在代码里没有改变 p 指向内存地址的值，那么这个值就一定不会发生改变。 此处说的「读取内存」，包括了读取 CPU 缓存和读取计算机主存。然而，由于 MMIP（Memory mapped I/O）的存在，这个假设不一定是真的。例如说，假设 p 指向的内存是一个硬件设备。这样一来，从 p 指向的内存读取数据可能伴随着可观测的副作用：硬件状态的修改。此时，代码的原意可能是将硬件设备返回的连续两个 int 分别保存在 a 和 b 当中。这种情况下，编译器的优化就会导致程序行为不符合预期了。 总结来说，被 volatile 修饰的变量，在对其进行读写操作时，会引发一些可观测的副作用。而这些可观测的副作用，是由程序之外的因素决定的。 关键字 volatile 的含义CPP reference 网站是对 C 和 C++ 语言标准的整理。因此，绝大多数时候，我们可以通过这个网站对语言标准进行查询。关于 volatile 关键字，有 C 语言标准和 C++ 语言标准可查。这里摘录两份标准对 volatile 访问的描述。 C 语言：Every access (both read and write) made through an lvalue expression of volatile-qualified type is considered an observable side effect for the purpose of optimization and is evaluated strictly according to the rules of the abstract machine (that is, all writes are completed at some time before the next sequence point). This means that within a single thread of execution, a volatile access cannot be optimized out or reordered relative to another visible side effect that is separated by a sequence point from the volatile access.C++ 语言：Every access (read or write operation, member function call, etc.) made through a glvalue expression of volatile-qualified type is treated as a visible side-effect for the purposes of optimization (that is, within a single thread of execution, volatile accesses cannot be optimized out or reordered with another visible side effect that is sequenced-before or sequenced-after the volatile access. This makes volatile objects suitable for communication with a signal handler, but not with another thread of execution, see std::memory_order). Any attempt to refer to a volatile object through a non-volatile glvalue (e.g. through a reference or pointer to non-volatile type) results in undefined behavior.这里首先解释两组概念：值类型和序列点（执行序列）。 值类型指的是左值（lvalue）右值（rvalue）这些概念。关于左值和右值，前作有过介绍。简单的理解，左值可以出现在赋值等号的左边，使用时取的是作为对象的身份；右值不可以出现在赋值等号的左边，使用时取的是对象的值。除了 lvalue 和 rvalue，C++ 还定义了其他的值类型。其中，xvalue 大体可以理解为返回右值引用的函数调用或表达式，而 glvalue 则是 lvalue 和 xvalue 之和。 序列点则是 C/C++ 中讨论执行顺序时会提到的概念。对于 C/C++ 的表达式来说，执行表达式有两种类型的动作：(1) 计算某个值、(2) 副作用（例如访问 volatile 对象，原子同步，修改文件等）。因此，如果在两个表达式 E1 和 E2 中间有一个序列点，或者在 C++ 中 E1 于序列中在 E2 之前，则 E1 的求值动作和副作用都会在 E2的求值动作和副作用之前。关于序列点和序列顺序规则，可以参考：这里和这里。 因此我们讲，在 C/C++ 中，对 volatile 对象的访问，有编译器优化上的副作用： 不允许被优化消失（optimized out）；于序列上在另一个对 volatile 对象的访问之前。这里提及的「不允许被优化」表示对 volatile 变量的访问，编译器不能做任何假设和推理，都必须按部就班地与「内存」进行交互。因此，上述例中「复用寄存器中的值」就是不允许的。 需要注意的是，无论是 C 还是 C++ 的标准，对于 volatile 访问的序列性，都有单线程执行的前提。其中 C++ 标准特别提及，这个顺序性在多线程环境里不一定成立。 volatile 与多线程volatile 可以解决多线程中的某些问题，这一错误认识荼毒多年。例如，在知乎「volatile」话题下的介绍就是「多线程开发中保持可见性的关键字」。为了拨乱反正，这里先给出结论（注意这些结论都基于本文第一节提出的约定之上）： volatile 不能解决多线程中的问题。按照 Hans Boehm &amp; Nick Maclaren 的总结，volatile 只在三种场合下是合适的。和信号处理（signal handler）相关的场合；和内存映射硬件（memory mapped hardware）相关的场合；和非本地跳转（setjmp 和 longjmp）相关的场合。 以下我们尝试来用 volatile 关键字解决多线程同步的一个基本问题：happens-before。 naïve case首先我们考虑这样一段（伪）代码。 // global shared databool flag = false; thread1() { flag = false; Type* value = new Type(/* parameters */); thread2(value); while (true) { if (flag == true) { apply(value); break; } } thread2.join(); if (nullptr != value) { delete value; } return;} thread2(Type* value) { // do some evaluations value-&gt;update(/* parameters */); flag = true; return;}这段代码将 thread1 作为主线程，等待 thread2 准备好 value。因此，thread2 在更新 value 之后将 flag 置为真，而 thread1 死循环地检测 flag。简单来说，这段代码的意图希望实现 thread2 在 thread1 使用 value 之前执行完毕这样的语义。 对多线程编程稍有了解的人应该知道，这段代码是有问题的。问题主要出在两个方面。其一，在 thread1 中，flag = false 到 while 死循环里，没有任何机会对 flag 的值做修改，因此编译器可能会将 if (flag == true) 的内容全部优化掉。其二，在 thread2 中，尽管逻辑上 update 需要发生在 flag = true 之前，但编译器和 CPU 并不知道；因此 flag = true 可能发生在 update 完成之前，因此 thread1 执行 apply(value) 时可能 value 还未准备好。 加一个 volatile 试试？在错误的理解中，此时就到了 volatile 登场的时候了。 首先我们考虑这样一段（伪）代码。 // global shared datavolatile bool flag = false; // 1. thread1() { flag = false; Type* value = new Type(/* parameters */); thread2(value); while (true) { if (flag == true) { // 2. apply(value); break; } } thread2.join(); if (nullptr != value) { delete value; } return;} thread2(Type* value) { // do some evaluations value-&gt;update(/* parameters */); flag = true; return;}这里，在 (1) 处，我们将 flag 声明为 volatile-qualified。因此，在 (2) 处，由于 flag == true 是对 volatile 变量的访问，故而 if-block 不会被优化消失。然而，尽管 flag 是 volatile-qualified，但 value并不是。因此，编译器仍有可能在优化时将 thread2 中的 update 和对 flag 的赋值交换顺序。此外，由于 volatile 禁止了编译器对 flag 的优化，这样使用 volatile 不仅无法达成目的，反而会导致性能下降。 再加一个 volatile 呢？在错误的理解中，可能会对 value 也加以 volatile 关键字修饰；颇有些「没有什么是一个 volatile 解决不了的；如果不行，那就两个」的意思。 // global shared datavolatile bool flag = false; thread1() { flag = false; volatile Type* value = new Type(/* parameters */); // 1. thread2(value); while (true) { if (flag == true) { apply(value); break; } } thread2.join(); if (nullptr != value) { delete value; } return;} thread2(volatile Type* value) { // do some evaluations value-&gt;update(/* parameters */); // 2. flag = true; return;}在上一节代码的基础上，(1) 将 value 声明为 volatile-qualified。因此 (2) 处对两个 volatile-qualified 变量进行访问时，编译器不会交换他们的顺序。看起来就万事大吉了。 然而，volatile 只作用在编译器上，但我们的代码最终是要运行在 CPU 上的。尽管编译器不会将 (2) 处换序，但 CPU 的乱序执行（out-of-order execution）已是几十年的老技术了；在 CPU 执行时，value 和 flag 的赋值仍有可能是被换序了的（store-store）。此外，(2) 处的 value = new Type() 一行代码并不如想象中那么简单。它实际上大概做了三件事情 分配一块 sizeof(Type) 大小的内存；在这块内存上，执行 Type 类型的初始化；将这块内存的首地址赋值给 value。对于编译器来说，这些工作都是改表达式语句的求值和副作用，因此不会与 flag 赋值语句换序。但是，在 CPU 乱序执行之下，甚至有可能发生 value 和 flag 已赋值完毕，但内存里尚未完成 Type 初始化的情况。此时若 thread1 中使用 value，则程序可能崩溃。 也许有人会说，x86 和 AMD64 架构的 CPU（大多数个人机器和服务器使用这两种架构的 CPU）只允许 sotre-load 乱序，而不会发生 store-store 乱序；或者在诸如 IA64 架构的处理器上，对 volatile-qualified 变量的访问采用了专门的指令。因而，在这些条件下，这段代码是安全的。尽管如此，使用 volatile 会禁止编译器优化相关变量，从而降低性能，所以也不建议依赖 volatile 在这种情况下做线程同步。另一方面，这严重依赖具体的硬件规范，超出了本文的约定讨论范围。到底应该怎样做？回顾一下，我们最初遇到的问题其实需要解决两件事情。一是 flag 相关的代码块不能被轻易优化消失，二是要保证线程同步的 happens-before 语义。但本质上，设计使用 flag 本身也就是为了构建 happens-before 语义。这也就是说，两个问题，后者才是核心；如有其他不用 flag 的办法解决问题，那么 flag 就不重要。 对于当前问题，最简单的办法是使用原子操作。 // global shared datastd::atomic flag = false; // #include thread1() { flag = false; Type* value = new Type(/* parameters */); thread2(value); while (true) { if (flag == true) { apply(value); break; } } thread2.join(); if (nullptr != value) { delete value; } return;} thread2(Type* value) { // do some evaluations value-&gt;update(/* parameters */); flag = true; return;}由于对 std::atomic 的操作是原子的，同时构建了良好的内存屏障，因此整个代码的行为在标准下是良定义的。 除此之外，还可以结合使用互斥量和条件变量。 // global shared datastd::mutex m; // #include std::condition_variable cv; // #include bool flag = false; thread1() { flag = false; Type* value = new Type(/* parameters */); thread2(value); std::unique_lockstd::mutex lk(m); cv.wait(lk, { return flag; }); apply(value); lk.unlock(); thread2.join(); if (nullptr != value) { delete value; } return;} thread2(Type* value) { std::lock_guardstd::mutex lk(m); // do some evaluations value-&gt;update(/* parameters */); flag = true; cv.notify_one(); return;}这样一来，由线程之间的同步由互斥量和条件变量来保证，同时也避免了 while (true) 死循环空耗 CPU 的情况。 原文地址：https://zhuanlan.zhihu.com/p/33074506 https://www.jb51.net/article/179240.htmhttps://www.huaweicloud.com/articles/e4e3ee53e594c40a9ad3da9687f94bc7.htmlhttps://www.yht7.com/news/29698https://blog.csdn.net/qq100440110/article/details/51858626https://www.jianshu.com/p/380b041b5aa6 https://blog.csdn.net/gjq_1988/article/details/39520729https://segmentfault.com/a/1190000025183443https://blog.csdn.net/dd864140130/article/details/56494925","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}]},{"title":"static详解(转)","slug":"language_c_cpp_keyword_static_c","date":"2021-03-15T14:15:07.449Z","updated":"2021-03-24T13:18:04.125Z","comments":true,"path":"2021/03/15/language_c_cpp_keyword_static_c/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_keyword_static_c/","excerpt":"","text":"static详解static 作为关键字出现在C++语言当中,其运用比较复杂,其修饰全局变量,局部变量,类成员变量,类成员函数等都有不同释义,下面为大家详细描述一下.一 static概述static 从笼统意义的理解上,可以理解为 被此关键字修饰过的函数或变量,即为静态函数或静态变量.静态变量或函数式在系统编译期,main函数运行前就已经分配内存的.在声明它的程序块,子程序块或函数内部有效,值保持虽然上面讲了static关键字修饰不同的类型单位会有不同的效果,但其实可以理解为面向过程程序中的static和面向对象程序中的static,面向过程中的static主要适用于普通变量和函数.面向对象中的static主要适用于类中的成员变量和成员函数.二 static用法详解面向过程中的static静态全局变量在全局变量之前,加上关键字static,就可以定义该变量为静态全局变量.例:#include&lt;stdio.h&gt;static int Temp = 10;void Test();int main(){ printf(“Temp is %d\\n”, Temp);//输出:10 Test();//输出:10 printf(“Temp is %d\\n”, Temp);//输出:11 return 0;}void Test(){ Temp++;}局部变量之前加上static,可以指定该局部变量为静态局部变量 代码中主要有一下几个特点01.在全局数据中的变量如果没有显示的初始化会自动被程序初始化为0(这个特性非静态全局变量也有),而在函数体内声明的变量如果不显示初始化则会使一个随机值.02.静态全局变量在声明它的整个文件中都是课件的,而在文件之外是不可见的,这点区别于全局变量.03.静态全局变量在全局数据区分配内存04.其他文件中可以定义同名int型变量Temp,不会冲突,各取各的值.有一定C++语言功底的朋友可能看出,上面的示例代码 其实如果将Temp的static去掉,程序也可以正常执行.但是请注意以下区别.01.全局变量时不显示调用static关键字修饰的变量,全局变量默认是有外部连接性的,其作用域是整个工程,在一个文件内定义的全局变量可以通过,包含其所在头文件或显示调用 extern关键字修饰全局变量的变量名声明来引用.02.静态全局变量是显示调用static修饰的全局变量,其作用域只在声明此变量的文件中,其他文件即使使用extern关键字修饰其声明也不可使用.03.关于第二点,其描述是C++标准,但是有些编译器会不执行次标准特意对其进行优化,目前亲测的vs2012与g++都不支持这个标准…个人表示也是醉了 静态局部变量在局部变量之前加上static,可以指定该局部变量为静态局部变量#include &lt;stdio.h&gt;void Test();int main(){ for(int i=0; i&lt;5; i++) { Test(); } return 0;}void Test(){ static Temp = 10; printf(“Temp is %d\\n”, Temp); Temp++;}以上程序输出为: 1011121314通常,在一个函数作用域内定义一个变量,每次运行到该函数时,系统会给局部变量分配内存,当函数结束时,该变量的内存会被系统回收至栈内存当中,局部变量也会消散.但是如果改局部变量被声明为static 静态局部变量时,则该变量的生命周期不受到该函数的作用域限制,也就是说即使函数运行结束,系统仍然会保留该静态变量的内存,不会回收,它始终驻留在全局数据区当中,直到整个进程程序运行结束时,其内存才会被回收.静态局部变量有以下特点:01.其内存存放在 程序的全局数据区中,02.静态局部变量在程序执行到该对象声明时,会被首次初始化.其后运行到该对象的声明时,不会再次初始化,这也是为什么上面程序测试函数每次输出的值都是递增的原因.03.如果静态局部变量没有被显示初始化,则其值会自动被系统初始化为0.04.局部静态变量 不能被其作用域之外的其他模块调用,其调用范围仅限于声明该变量的函数作用域当中. 静态函数在函数的返回类型前加上关键字static,可以将此函数声明为静态函数.静态函数与普通函数不同,其作用域只在声明它的文件当中.其他文件可以定义同名的全局函数,而不冲突.想要在其他文件调用静态函数 需要显示的调用extern关键字修饰其声明.否则编译器会link error.#include&lt;stdio.h&gt;static void Test();int main(){ Test(); return 0;}void Test(){ printf(“Is Static Fun\\n”);}总结定义静态函数的好处: 01.其他文件可以定义同名函数02.静态函数不会被其他文件所引用,其作用域只在当前声明他的文件中. 面向对象中的static静态数据成员在类内的数据成员声明前加上关键字static,则该成员将会被声明为静态数据成员.#include &lt;stdio.h&gt;class TempClass{public: TempClass(int a, int b, int c); void Show();private: int a,b,c; static int T;}int TempClass::T = 0;//初始化静态数据成员TempClass::TempClass(int a, int b, int c){ this-&gt;a = a; this-&gt;b = b; this-&gt;c = c; T = a + b + c;}void TempClass::Show(){ printf(“T is %d\\n”, T);}int main(){ TempClass ClassA(1,1,1); ClassA.Show();//输出1+1+1 = 3; TempClass ClassB(3,3,3); ClassB.Show();//输出3+3+3 = 9; ClassA.Show();//输出9 return 0;}从上面的测试代码可以看出 静态数据成员的特点: 01.静态数据成员的服务对象并非是单个类实例化的对象,而是所有类实例化的对象(这点可以用于设计模式中的单例模式实现).02.静态数据成员必须显示的初始化分配内存,在其包含类没有任何实例花之前,其已经有内存分配.03.静态数据成员与其他成员一样,遵从public,protected,private的访问规则.04.静态数据成员内存存储在全局数据区,只随着进程的消亡而消亡. 静态数据成员与全局变量相比的优势:01.静态数据成员不进入程序全局名字空间,不会与其他全局名称的同名同类型变量冲突.02.静态数据成员可以实现C++的封装特性,由于其遵守类的访问权限规则.所以相比全局变量更加灵活. 静态成员函数在类的成员函数返回类型之前添加static,即可声明此成员函数为静态成员函数.#include &lt;stdio.h&gt; class TempClass{public: TempClass(int a, int b, int c); static void Show();private: int a,b,c; static int T;}int TempClass::T = 0; //初始化静态数据成员TempClass::TempClass(int a, int b, int c){ this-&gt;a = a; this-&gt;b = b; this-&gt;c = c; T = a + b + c;}void TempClass::Show(){ printf(“T is %d\\n”, T);}int main(){ TempClass ClassA(1,1,1); ClassA.Show(); TempClass ClassB(3,3,3); ClassB.Show(); TempClass::Show(); //注意此处的调用方式. return 0; }从上面的示例代码中可以看出 静态局部函数的特点如下: 01.静态成员函数比普通成员函数多了一种调用方式.02.静态成员函数为整个类服务,而不是具体的一个类的实例服务.(这句话可能比较绕口,可以理解为在没有任何实例化的类对象的条件下调用类方法,详见上面代码注释处.)03.静态成员函数中没有隐含的this指针,所以静态成员函数不可以操作类中的非静态成员. ps:关于this指针的深入解释在C++中,普通的成员函数一般都隐含了一个this指针,例如调用函数Fun(),实际上是this-&gt;Fun().静态成员函数中没有这样的this指针,所以静态成员函数不能操作类中的非静态成员函数.否则编译器会报错. 三 注意事项01.静态数据成员都是静态存储的,所以必须在main函数之前显示的对其进行初始化.02.静态成员初始化与一般成员的初始化不同.03.不能再头文件中声明静态全局变量,这点在简单的测试代码中无法体现,只有在多文件同时包含,引用和操作时候才会显露出来.其结果可能是产生了多个同名的静态数据.一旦出现这种问题,是非常难以查找和排除的.04.不能将静态成员函数定义为虚函数.05.静态成员函数没有this指针.06.static缩短了子类对父类静态成员访问的时间,相对来说节省了内存空间07.关于06条的补充,如果不想在子类中操作父类的静态成员,则可以在子类中定义一个同名的static成员.这样既可覆盖父类中的静态成员.并且根据C++的多态性变量命名规则.这样做是安全的.08.静态成员声明在类中,操作在其外部,所以对其取地址操作就跟取普通成员的操作略有不同.静态变量地址是指向其数据类型的指针,函数地址则是一个类型为nonmember的函数指针.————————————————版权声明：本文为CSDN博主「鬼筠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/u010797208/article/details/41549461","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"sizeof详解","slug":"language_c_cpp_keyword_sizeof_1","date":"2021-03-15T14:14:56.906Z","updated":"2021-03-17T13:48:27.101Z","comments":true,"path":"2021/03/15/language_c_cpp_keyword_sizeof_1/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_keyword_sizeof_1/","excerpt":"","text":"sizeof是关键字&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizeof 是关键字不是函数，其实就算不知道它是否为32 个关键字之一时，我们也可以借助编译器确定它的身份。看下面的例子：int i=0；A),sizeof(int)； B)，sizeof(i)； C)，sizeof int； D)，sizeof i； &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;毫无疑问，32 位系统下A)，B)的值为4。那C)的呢？D)的呢？在32 位系统下，我们发现D)的结果也为4。咦？sizeof 后面的括号呢？没有括号居然也行，那想想，函数名后面没有括号行吗？由此轻易得出sizeof 绝非函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好，再看C)。编译器怎么怎么提示出错呢？不是说sizeof 是个关键字，其后面的括号可以没有么？那你想想sizeof int 表示什么啊？int 前面加一个关键字？类型扩展？明显不正确，我们可以在int 前加unsigned，const 等关键字但不能加sizeof。 由几个例子说开去。 int *p = NULL;sizeof(p)的值是多少？sizeof(*p)呢？是一个宏定义，所有NULL直接替换成0。sizeof(NULL)就是sizeof(0)，视为对整数求sizeof，返回默认整型（int型）的sizeof，4。 第一个例子：01.char* ss = “0123456789”;02.sizeof(ss) 结果 4 ＝＝＝》ss是指向字符串常量的字符指针03.sizeof(ss) 结果 1 ＝＝＝》ss是第一个字符04.05.char ss[] = “0123456789”;06.sizeof(ss) 结果 11 ＝＝＝》ss是数组，计算到\\0位置，因此是10＋107.sizeof(ss) 结果 1 ＝＝＝》ss是第一个字符08.09.char ss[100] = “0123456789”;10.sizeof(ss) 结果是100 ＝＝＝》ss表示在内存中的大小 100×111.strlen(ss) 结果是10 ＝＝＝》strlen是个函数内部实现是用一个循环计算到\\0为止之前12.13.int ss[100] = “0123456789”;14.sizeof(ss) 结果 400 ＝＝＝》ss表示再内存中的大小 100×415.strlen(ss) 错误 ＝＝＝》strlen的参数只能是char* 且必须是以’’\\0’’结尾的16.17.char q[]=”abc”;18.char p[]=”a\\n”;19.sizeof(q),sizeof(p),strlen(q),strlen(p);20.结果是 4 3 3 2第二个例子：01.class X02.{03.int i;04.int j;05.char k;06.};07.X x;08.cout&lt;&lt;sizeof(X)&lt;&lt;endl; 结果 12 ＝＝＝》内存补齐09.cout&lt;&lt;sizeof(x)&lt;&lt;endl; 结果 12 同上第三个例子：1.char szPath[MAX_PATH]如果在函数内这样定义，那么sizeof(szPath)将会是MAX_PATH，但是将szPath作为虚参声明时（void fun(char szPath[MAX_PATH])）,sizeof(szPath)却会是4(指针大小)三、sizeof深入理解。1.sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。该类型保证能容纳实现所建立的最大对象的字节大小。2.sizeof是算符，strlen是函数。3.sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以’’\\0’’结尾的。sizeof还可以用函数做参数，比如：1.short f();2.printf(“%d\\n”, sizeof(f()));输出的结果是sizeof(short)，即2。4.数组做sizeof的参数不退化，传递给strlen就退化为指针了。5.大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因1.char str[20]=”0123456789”;2.int a=strlen(str); //a=10;3.int b=sizeof(str); //而b=20;6.strlen的结果要在运行的时候才能计算出来，时用来计算字符串的长度，不是类型占内存的大小。7.sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。8.当适用了于一个结构类型时或变量， sizeof 返回实际的大小， 当适用一静态地空间数组， sizeof 归还全部数组的尺 寸。 sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸9.数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址，如：1.fun(char [8])2.fun(char [])都等价于 fun(char *) 在C++里传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小如果想在函数内知道数组的大小， 需要这样做：进入函数后用memcpy拷贝出来，长度由另一个形参传进去1.fun(unsiged char p1, int len)2.{3. unsigned char buf = new unsigned char[len+1]4. memcpy(buf, p1, len);5.}有关内容见： C++ PRIMER?10.计算结构变量的大小就必须讨论数据对齐问题。为了CPU存取的速度最快（这同CPU取数操作有关，详细的介绍可以参考一些计算机原理方面的书），C++在处理数据时经常把结构变量中的成员的大小按照4或8的倍数计算，这就叫数据对齐（data alignment）。这样做可能会浪费一些内存，但理论上速度快了。当然这样的设置会在读写一些别的应用程序生成的数据文件或交换数据时带来不便。MS VC++中的对齐设定，有时候sizeof得到的与实际不等。一般在VC++中加上#pragma pack(n)的设定即可.或者如果要按字节存储，而不进行数据对齐，可以在Options对话框中修改Advanced compiler页中的Data alignment为按字节对齐。11.sizeof操作符不能用于函数类型，不完全类型或位字段。不完全类型指具有未知存储大小的数据类型，如未知存储大小的数组类型、未知内容的结构或联合类型、void类型等。如sizeof(max)若此时变量max定义为int max(),sizeof(char_v) 若此时char_v定义为char char_v [MAX]且MAX未知，sizeof(void)都不是正确形式 四、结束语sizeof使用场合。1.sizeof操作符的一个主要用途是与存储分配和I/O系统那样的例程进行通信。例如：1.voidmalloc（size_tsize）,2.size_tfread(void ptr,size_tsize,size_tnmemb,FILE* stream)。2.用它可以看看一类型的对象在内存中所占的单元字节。1.voidmemset（void s,intc,sizeof(s)）3.在动态分配一对象时,可以让系统知道要分配多少内存。4.便于一些类型的扩充,在windows中就有很多结构内型就有一个专用的字段是用来放该类型的字节大小。5.由于操作数的字节数在实现时可能出现变化，建议在涉及到操作数字节大小时用sizeof来代替常量计算。6.如果操作数是函数中的数组形参或函数类型的形参，sizeof给出其指针的大小。 源文档 http://www.vckbase.com/index.php/wv/789","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"register详解","slug":"language_c_cpp_keyword_register","date":"2021-03-15T14:14:13.222Z","updated":"2021-03-17T00:15:16.839Z","comments":true,"path":"2021/03/15/language_c_cpp_keyword_register/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_keyword_register/","excerpt":"","text":"用register说明的局部变量称为寄存器变量，该变量将可能以寄存器作为存储空间。register说明仅能建议（而非强制）系统使用寄存器，这是因为寄存器虽然存取速度快，但个数有限，当寄存器不够用时，该变量仍按auto变量处理。 一般在短时间内被频繁访问的变量置于寄存器中可提高效率。不过并不建议经常使用register变量，理由如下。 在许多情况下使用register变量效果并不明显； 有些版本的C++编译系统具有对局部变量按某种策略自动决定可否占用可用寄存器的功能，效果比程序员决定可能要好一些； 局部变量存于寄存器时它将没有内存地址，可能影响与寻址有关的操作，如寻址运算符&amp;的操作。 demo inline int encodeVLB8 ( BYTE * buf, uint64_t v ){ register BYTE b; register int n = 0; do { b = (BYTE)(v &amp; 0x7f); v &gt;&gt;= 7; if ( v ) b |= 0x80; *buf++ = b; n++; } while ( v ); return n;} 注： sphinx-2.0.5-release 参考资料https://blog.csdn.net/theusProme/article/details/55094507","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"mutable详解","slug":"language_c_cpp_keyword_mutable","date":"2021-03-15T14:13:36.694Z","updated":"2021-03-16T23:51:10.825Z","comments":true,"path":"2021/03/15/language_c_cpp_keyword_mutable/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_keyword_mutable/","excerpt":"","text":"类中的 mutablemutable 从字面意思上来说，是「可变的」之意。 若是要「顾名思义」，那么这个关键词的含义就有些意思了。显然，「可变的」只能用来形容变量，而不可能是「函数」或者「类」本身。然而，既然是「变量」，那么它本来就是可变的，也没有必要使用 mutable 来修饰。那么，mutable 就只能用来形容某种不变的东西了。 C++ 中，不可变的变量，称之为常量，使用 const 来修饰。然而，若是 const mutable 联用，未免让人摸不着头脑——到底是可变还是不可变呢？ 事实上，mutable 是用来修饰一个 const 示例的部分可变的数据成员的。如果要说得更清晰一点，就是说 mutable 的出现，将 C++ 中的 const 的概念分成了两种。 二进制层面的 const，也就是「绝对的」常量，在任何情况下都不可修改（除非用 const_cast）。引入 mutable 之后，C++ 可以有逻辑层面的 const，也就是对一个常量实例来说，从外部观察，它是常量而不可修改；但是内部可以有非常量的状态。当然，所谓的「逻辑 const」，在 C++ 标准中并没有这一称呼。这只是为了方便理解，而创造出来的名词。 显而易见，mutable 只能用来修饰类的数据成员；而被 mutable 修饰的数据成员，可以在 const 成员函数中修改。 这里举一个例子，展现这类情形。 class HashTable { public: //… std::string lookup(const std::string&amp; key) const { if (key == last_key_) { return last_value_; } std::string value&#123;this-&gt;lookupInternal(key)&#125;; last_key_ = key; last_value_ = value; return value; &#125; private: mutable std::string last_key_ mutable std::string last_value_;};这里，我们呈现了一个哈希表的部分实现。显然，对哈希表的查询操作，在逻辑上不应该修改哈希表本身。因此，HashTable::lookup 是一个 const 成员函数。在 HashTable::lookup 中，我们使用了 last_key_ 和 last_value_ 实现了一个简单的「缓存」逻辑。当传入的 key 与前次查询的 last_key_ 一致时，直接返回 last_value_；否则，则返回实际查询得到的 value 并更新 last_key_ 和 last_value_。 在这里，last_key_ 和 last_value_ 是 HashTable 的数据成员。按照一般的理解，const 成员函数是不允许修改数据成员的。但是，另一方面，last_key_ 和 last_value_ 从逻辑上说，修改它们的值，外部是无有感知的；因此也就不会破坏逻辑上的 const。为了解决这一矛盾，我们用 mutable 来修饰 last_key_ 和 last_value_，以便在 lookup 函数中更新缓存的键值。 Lambda 表达式中的 mutableC++11 引入了 Lambda 表达式，程序员可以凭此创建匿名函数。在 Lambda 表达式的设计中，捕获变量有几种方式；其中按值捕获（Caputre by Value）的方式不允许程序员在 Lambda 函数的函数体中修改捕获的变量。而以 mutable 修饰 Lambda 函数，则可以打破这种限制。 int x{0};auto f1 = = mutable {x = 42;}; // okay, 创建了一个函数类型的实例auto f2 = = {x = 42;}; // error, 不允许修改按值捕获的外部变量的值需要注意的是，上述 f1 的函数体中，虽然我们给 x 做了赋值操作，但是这一操作仅只在函数内部生效——即，实际是给拷贝至函数内部的 x 进行赋值——而外部的 x 的值依旧是 0。 源地址https://www.zhihu.com/question/64969053","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}]},{"title":"extern详解","slug":"language_c_cpp_keyword_extern","date":"2021-03-15T14:13:05.031Z","updated":"2021-03-16T23:35:44.554Z","comments":true,"path":"2021/03/15/language_c_cpp_keyword_extern/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_keyword_extern/","excerpt":"","text":"1 基本解释extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。另外，extern也可用来进行链接指定。2 问题：extern 变量在一个源文件里定义了一个数组：char a[6];在另外一个文件里用下列语句进行了声明：extern char a；请问，这样可以吗？ 答案与分析：1)、不可以，程序运行时会告诉你非法访问。原因在于，指向类型T的指针并不等价于类型T的数组。extern char a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[ ]。2)、例子分析如下，如果a[] = “abcd”,则外部变量a=0x61626364 (abcd的ASCII码值)，a显然没有意义显然a指向的空间（0x61626364）没有意义，易出现非法内存访问。3)、这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。4)、extern用在变量声明中常常有这样一个作用，你在.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在*.h中并用extern来声明。4 问题：extern 函数2当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern申明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？答案与分析：目前业界针对这种情况的处理没有一个很完美的方案，通常的做法是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。宝剑有双锋，对extern的应用，不同的场合应该选择不同的做法。5 问题：extern “C”在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？答案与分析：C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。下面是一个标准的写法：//在.h文件的头上#ifdef __cplusplus#if __cplusplusextern “C”{#endif#endif /* __cplusplus */ ……//.h文件结束的地方#ifdef __cplusplus#if __cplusplus}#endif#endif /* __cplusplus / 3 问题：extern 函数1常常见extern放在函数的前面成为函数声明的一部分，那么，C语言的关键字extern在函数的声明中起什么作用？答案与分析：如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。即下述两个函数声明没有明显的区别：extern int f(); 和int f();当然，这样的用处还是有的，就是在程序中取代include “.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。 源文档 http://www.cnblogs.com/luliang/archive/2008/08/21/1272746.html","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}]},{"title":"const详解","slug":"language_c_cpp_keyword_const","date":"2021-03-15T14:12:10.599Z","updated":"2021-03-16T23:34:58.715Z","comments":true,"path":"2021/03/15/language_c_cpp_keyword_const/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_keyword_const/","excerpt":"","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C++中的const关键字的用法非常灵活，而使用const将大大改善程序的健壮性，本人根据各方面查到的资料进行总结如下，期望对朋友们有所帮助。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。 一、Const作用 如下表所示： No. 作用 说明 参考代码 1 可以定义const常量 const int Max = 100;&nbsp; 2 便于进行类型检查 const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误 void f(const int i) { .........} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //对传入的参数进行类型检查，不匹配进行提示 3 可以保护被修饰的东西 防止意外的修改，增强程序的健壮性。 void f(const int i) { i=10;//error! } &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //如果在函数体内修改了i，编译器就会报错 4 可以很方便地进行参数的调整和修改 同宏定义一样，可以做到不变则已，一变都变 5 为函数重载提供了一个参考 class A { &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...... &nbsp; void f(int i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {......} //一个函数 &nbsp; void f(int i) const {......} //上一个函数的重载 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...... }; 6 可以节省空间，避免不必要的内存分配 const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝 #define PI 3.14159&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //常量宏 const doulbe&nbsp; Pi=3.14159;&nbsp; //此时并未将Pi放入ROM中 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...... double i=Pi;&nbsp;&nbsp; //此时为Pi分配内存，以后不再分配！ double I=PI;&nbsp; //编译期间进行宏替换，分配内存 double j=Pi;&nbsp; //没有内存分配 double J=PI;&nbsp; //再进行宏替换，又一次分配内存！ 7 &nbsp;提高了效率 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高 二、Const的使用 1、定义常量(1)const修饰变量，以下两种定义形式在本质上是一样的。它的含义是：const修饰的类型为TYPE的变量value是不可变的。 TYPE const ValueName = value; const TYPE ValueName = value; (2)将const改为外部连接,作用于扩大至全局,编译时会分配内存,并且可以不进行初始化,仅仅作为声明,编译器认为在程序其他地方进行了定义. extend const int ValueName = value; 2、指针使用CONST(1)指针本身是常量不可变 char* const pContent; (2)指针所指向的内容是常量不可变(注:可以这样理解，*pContent对应的是指针指向的内容，所以下面这种定义标识内容是常量不可改变) const char *pContent; (3)两者都不可变 const char* const pContent; (4)还有其中区别方法，沿着号划一条线：如果const位于的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。 3、函数中使用CONST (1)const修饰函数参数a.传递过来的参数在函数内不可以改变(无意义，因为Var本身就是形参) void function(const int Var); b.参数指针所指内容为常量不可变 void function(const char* Var); c.参数指针本身为常量不可变(也无意义，因为char* Var也是形参) void function(char* const Var); d.参数为引用，为了增加效率同时防止修改。修饰引用参数时： void function(const Class&amp; Var); //引用参数在函数内不可以改变 void function(const TYPE&amp; Var); //引用参数在函数内为常量不可变 这样的一个const引用传递和最普通的函数按值传递的效果是一模一样的,他禁止对引用的对象的一切修改,唯一不同的是按值传递会先建立一个类对象的副本, 然后传递过去,而它直接传递地址,所以这种传递比按值传递更有效.另外只有引用的const传递可以传递一个临时对象,因为临时对象都是const属性, 且是不可见的,他短时间存在一个局部域中,所以不能使用指针,只有引用的const传递能够捕捉到这个家伙. (2)const 修饰函数返回值 const修饰函数返回值其实用的并不是很多，它的含义和const修饰普通变量以及指针的含义基本相同。 a.const int fun1() //这个其实无意义，因为参数返回本身就是赋值。 b. const int * fun2() //调用时 const int pValue = fun2(); //我们可以把fun2()看作成一个变量，即指针内容不可变。 c.int const fun3() //调用时 int * const pValue = fun2(); //我们可以把fun2()看作成一个变量，即指针本身不可变。 一般情况下，函数的返回值为某个对象时，如果将其声明为const时，多用于操作符的重载。通常，不建议用const修饰函数的返回值类型为某个对象或对某个对象引用的情况。原因如下：如果返回值为某个对象为const（const A test = A 实例）或某个对象的引用为const（const A&amp; test = A实例） ，则返回值具有const属性，则返回实例只能访问类A中的公有（保护）数据成员和const成员函数，并且不允许对其进行赋值操作，这在一般情况下很少用到。 4、类相关CONST (1)const修饰成员变量const修饰类的成员函数，表示成员常量，不能被修改，同时它只能在初始化列表中赋值。 class A { … const int nValue; //成员常量不能被修改 … A(int x): nValue(x) { } ; //只能在初始化列表中赋值 } (2)const修饰成员函数const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。一般写在函数的最后来修饰。 class A { … void function()const; //常成员函数, 它不改变对象的成员变量. //也不能调用类中任何非const成员函数。} 对于const类对象/指针/引用，只能调用类的const成员函数，因此，const修饰成员函数的最重要作用就是限制对于const对象的使用。 a. const成员函数不被允许修改它所在对象的任何一个数据成员。 b. const成员函数能够访问对象的const成员，而其他成员函数不可以。 (3)const修饰类对象/对象指针/对象引用 · const修饰类对象表示该对象为常量对象，其中的任何成员都不能被修改。对于对象指针和对象引用也是一样。 · const修饰的对象，该对象的任何非const成员函数都不能被调用，因为任何非const成员函数会有修改成员变量的企图。例如：class AAA{ void func1();void func2() const;}const AAA aObj;aObj.func1(); ×aObj.func2(); 正确 const AAA* aObj = new AAA();aObj-&gt; func1(); ×aObj-&gt; func2(); 正确 三、将Const类型转化为非Const类型的方法 采用const_cast 进行转换。 用法：const_cast (expression)该运算符用来修改类型的const或volatile属性。除了const 或volatile修饰之外， type_id和expression的类型是一样的。 · 常量指针被转化成非常量指针，并且仍然指向原来的对象； · 常量引用被转换成非常量引用，并且仍然指向原来的对象； · 常量对象被转换成非常量对象。 四、使用const的一些建议 · 要大胆的使用const，这将给你带来无尽的益处，但前提是你必须搞清楚原委； · 要避免最一般的赋值操作错误，如将const变量赋值，具体可见思考题； · 在参数中使用const应该使用引用或指针，而不是一般的对象实例，原因同上； · const在成员函数中的三种用法（参数、返回值、函数）要很好的使用； · 不要轻易的将函数的返回值类型定为const; · 除了重载操作符外一般不要将返回值类型定为对某个对象的const引用; · 任何不会修改数据成员的函数都应该声明为const 类型。 五、补充重要说明 · 类内部的常量限制：使用这种类内部的初始化语法的时候，常量必须是被一个常量表达式 初始化的整型或枚举类型，而且必须是static和const形式。 · 如何初始化类内部的常量：一种方法就是static 和 const 并用，在外部初始化，例如： class A { public: A() {} private: static const int i; file://注意必须是静态的！ }； const int A::i=3;另一个很常见的方法就是初始化列表： class A { public: A(int i=0):test(i) {} private: const int i; }； 还有一种方式就是在外部初始化， · 如果在非const成员函数中，this指针只是一个类类型的；如果在const成员函数中， this指针是一个const类类型的；如果在volatile成员函数中,this指针就是一个 volatile类类型的。 六、存储空间说明 原地址：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; https://blog.csdn.net/eric_jo/article/details/4138548","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}]},{"title":"C语言运算符优先级","slug":"language_c_cpp_common_operator","date":"2021-03-15T05:02:23.047Z","updated":"2021-03-16T23:41:03.258Z","comments":true,"path":"2021/03/15/language_c_cpp_common_operator/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_common_operator/","excerpt":"","text":"优先级 运算符 名称或含义 使用形式 结合方向 说明 1 [] 数组下标 数组名[常量表达式] 左到右 () 圆括号 （表达式）/函数名(形参表) . 成员选择（对象） 对象.成员名 -&gt; 成员选择（指针） 对象指针-&gt;成员名 ++ 后置自增运算符 ++变量名 单目运算符 — 后置自减运算符 –变量名 单目运算符 2 – 负号运算符 -表达式 右到左 单目运算符 (类型) 强制类型转换 (数据类型)表达式 ++ 前置自增运算符 变量名++ 单目运算符 — 前置自减运算符 变量名– 单目运算符 * 取值运算符 *指针变量 单目运算符 &amp; 取地址运算符 &amp;变量名 单目运算符 ! 逻辑非运算符 !表达式 单目运算符 ~ 按位取反运算符 ~表达式 单目运算符 sizeof 长度运算符 sizeof(表达式) 3 / 除 表达式/表达式 左到右 双目运算符 * 乘 表达式*表达式 双目运算符 % 余数（取模） 整型表达式/整型表达式 双目运算符 4 + 加 表达式+表达式 左到右 双目运算符 – 减 表达式-表达式 双目运算符 5 &lt;&lt; 左移 变量&lt;&lt;表达式 左到右 双目运算符 &gt;&gt; 右移 变量&gt;&gt;表达式 双目运算符 6 &gt; 大于 表达式&gt;表达式 左到右 双目运算符 &gt;= 大于等于 表达式&gt;=表达式 双目运算符 &lt; 小于 表达式&lt;表达式 双目运算符 &lt;= 小于等于 表达式&lt;=表达式 双目运算符 7 == 等于 表达式==表达式 左到右 双目运算符 != 不等于 表达式!= 表达式 双目运算符 8 &amp; 按位与 表达式&amp;表达式 左到右 双目运算符 9 ^ 按位异或 表达式^表达式 左到右 双目运算符 10 | 按位或 表达式|表达式 左到右 双目运算符 11 &amp;&amp; 逻辑与 表达式&amp;&amp;表达式 左到右 双目运算符 12 || 逻辑或 表达式||表达式 左到右 双目运算符 13 ?: 条件运算符 表达式1? 表达式2: 表达式3 右到左 三目运算符 14 = 赋值运算符 变量=表达式 右到左 /= 除后赋值 变量/=表达式 *= 乘后赋值 变量*=表达式 %= 取模后赋值 变量%=表达式 += 加后赋值 变量+=表达式 -= 减后赋值 变量-=表达式 &lt;&lt;= 左移后赋值 变量&lt;&lt;=表达式 &gt;&gt;= 右移后赋值 变量&gt;&gt;=表达式 &amp;= 按位与后赋值 变量&amp;=表达式 ^= 按位异或后赋值 变量^=表达式 |= 按位或后赋值 变量|=表达式 15 , 逗号运算符 表达式,表达式,… 左到右 从左向右顺序运算 说明： 同一优先级的运算符，运算次序由结合方向所决定。 同一优先级的运算符，运算次序由结合方向所决定。 源地址：http://www.slyar.com/blog/c-operator-priority.html","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}]},{"title":"位操作及应用","slug":"language_c_cpp_skills_bit_1","date":"2021-03-15T01:42:19.228Z","updated":"2021-03-17T01:24:16.591Z","comments":true,"path":"2021/03/15/language_c_cpp_skills_bit_1/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_skills_bit_1/","excerpt":"","text":"1. “按位与”运算符（&amp;） 参加运算的两个数据，按二进位进行“与”运算。原则是全1为1,有0为0,即：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1; 如下例： a=5&3; //a=(0b 0101) &amp; (0b 0011) =0b 0001 =1 那么如果参加运算的两个数为负数，又该如何算呢？会以其补码形式表示的二进制数来进行与运算。 a=-5&amp;-3; //a=(0b 1011) &amp; (0b1101) =0b 1001 =-7 在实际的应用中与操作经常被用于实现特定的功能： 1）清零 “按位与”通常被用来使变量中的某一位清零。如下例： a=0xfe; //a=0b 11111110 a=a&0x55; //使变量a的第1位、第3位、第5位、第7位清零 a= 0b 01010100 2）检测位 要知道一个变量中某一位是‘1’还是‘0’，可以使用与操作来实现。 a=0xf5; //a=0b 11110101 result=a&0x08; //检测a的第三位,result=0 3）保留变量的某一位 要屏蔽某一个变量的其它位，而保留某些位，也可以使用与操作来实现。 a=0x55; //a=0b 01010101 a=a&0x0f; //将高四位清零，而保留低四位 a=0x05例子1:i &amp; 0x7F该方法中，0x7F的值为127，按位取反后0x7F的值为-128。当0&lt;=i&lt;=127时，(i &amp; ~0x7F) =0；当128&lt;=i&lt;=255时，(i &amp; ~0x7F) =128；当256&lt;=i&lt;=511时，(i &amp; ~0x7F) =256；以此类推。也就是说，判断的条件不等于0成立 ，i的取值范围是i&gt;=128。调用了RAMOutputStream类的writeBytes()方法，写入的字节值为(i &amp; 0x7f) | 0x80，因为，(i &amp; ~0x7F)的值为0，128，256，384，512……，再与0x80(即128)做按位或运算，也就是当(i &amp; 0x7f) 的值为0时，写入的字节是128，从而(i &amp; 0x7f) | 0x80为写入的值：128，256，384，512……，没有0了。 2. “按位或”运算符（｜）参与或操作的两个位，只要有一个为‘1’，则结果为‘1’。即有‘1’为‘1’，全‘0’为‘0’。0|0=0; 0|1=1; 1|0=1; 1|1=1;例如：a=0x30|0x0f; //a=(0b00110000)|(0b00001111)=(0b00111111)=0x3f “按位或”运算最普遍的应用就是对一个变量的某些位置‘1’。如下例： a=0x00; //a=0b 00000000 a=a|0x7f; //将a的低7位置为1,a=0x7f 3. “异或”运算符（＾） 异或运算符＾又被称为XOR运算符。当参与运算的两个位相同（‘1’与‘1’或‘0’与‘0’）时结果为‘0’。不同时为‘1’。即相同为0，不同为1 。 0^0=0; 0^1=1; 1^0=1;1^1=0;例如：a=0x55^0x3f; //a=(0b01010101)^(0b00111111)=(0b01101010)=0x6a 异或运算主要有以下几种应用：1）翻转某一位：当一个位与‘1’作异或运算时结果就为此位翻转后的值。如下例： a=0x35; //a=0b00110101 a=a^0x0f; //a=0b00111010 a的低四位翻转 关于异或的这一作用，有一个典型的应用，即取浮点的相反数，具体的实现如下： f=1.23; //f为浮点型变量 值为1.23 f=f*-1; //f乘以-1，实现取其相反数，要进行一次乘运算 f=1.23; ((unsigned char *)&amp;f)[0]^=0x80; //将浮点数f的符号位进行翻转实现取相反数2）保留原值：当一个位与‘0’作异或运算时，结果就为此位的值。如下例： a=0xff; //a=0b11111111 a=a^0x0f; //a=0b11110000 与0x0f作异或，高四位不变，低四位翻转3）交换两个变量的值，而不用临时变量，要交换两个变量的值，传统的方法都需要一个临时变量。实现如下： void swap(unsigned char *pa,unsigned char *pb) { unsigned char temp=*pa;//定义临时变量，将pa指向的变量值赋给它 *pa=*pb; *pb=temp; //变量值对调 } 而使用异或的方法来实现，就可以不用临时变量，如下： void swap_xor(unsigned char *pa,unsigned char *pb) { *pa=pa^pb; *pb=pa^pb; *pa=pa^pb; //采用异或实现变量对调 }几个经典的位运算函数4.1求当前机器无符号整型最大长度/the max length of unsigned int/int int_size (){ unsigned int bits; int size = 0; bits = ~0; while ( bits ) { ++size; bits &gt;&gt;= 1; } return size;} 4.2移位运算/a bit mover for unsigned int if n &gt; 0 move left for n bits,else move right/unsigned int bit_shift (unsigned int value,int n){ int intsize=int_size(); /the length of unsigned int/ if(n&gt;0 &amp;&amp; n&lt; intsize) /*move left*/ value&lt;&lt;=n; else if (n&lt;0 &amp;&amp; n&gt; -intsize) /move right/ value&gt;&gt;=-n; else value=0; return value;} 4.3循环移位运算/a bit rotate mover for unsigned int if n &gt; 0 move left for n bits,else move right/unsigned int bit_rotate (unsigned int value, int n){ unsigned int result,bits,intsize; intsize=int_size(); /the length of unsigned int/ if(n &gt; 0) n=n % intsize; else n=-(-n % intsize); if(n==0) result=value; else if(n &gt;0 ){ /move left/ bits=value &gt;&gt; (intsize-n);/bits should be in the rightest/ result=value &lt;&lt; n|bits; }else{ /*move right*/ n=-n; bits=value &lt;&lt; (intsize-n);/*bits should be in the leftest*/ result=value &gt;&gt; n|bits; } return result;} 4.4返回无符号整型数value中从右起第p位的值/* get bit No.p(from right) of value to see if it is on */int bit_get (unsigned int value, int p){ int intsize=int_size(); /the length of unsigned int/ if ( p &lt; 0 || p &gt; intsize-1 )/out of range/ return 0; if ( (value &gt;&gt; p) &amp; 1 ) return 1; else return 0;} 4.5将无符号整型数value中从右起的第p位置1/* set bit No.p(from right) of value on */unsigned int bit_set (unsigned int value, int p){ int intsize=int_size(); /the length of unsigned int/ if ( p &lt; 0 || p &gt; intsize-1 )/out of range/ return 0; return value | (1 &lt;&lt; p);} 4.6返回无符号整型数value中从第p位(右起)向右n位的值[1](0 &lt;&lt; n)表示最右边n位全为1;[2]value &gt;&gt; (p+1-n)表示将目标位字段移至最右端;/*get n bits of value at position p(from right) */unsigned bits_get (unsigned int value, int p, int n){ int intsize=int_size(); /the length of unsigned int/ if ( n &lt; 0 || p &lt; 0 || p + n &gt; intsize ) return 0; return(value &gt;&gt; (p+1-n)) &amp; (0 &lt;&lt; n);} 4.7将无符号整型数value中从第p位(右起)向右n位设置为y最右边n位的值[1](0 &lt;&lt; n)表示最右边n位全为1;[2]((0 &lt;&lt; n) &lt;&lt; (p+1-n)表示将这n个1位左移至位置p;[3]((~0 &lt;&lt; n) &lt;&lt; (p+1-n))表示将从位置p开始的n位设置零,其余位设置一;[4]unsigned tar=bits_get(y,n-1,n);取出y的低n位;/set n bits of value at position p(from right) with bits of y/unsigned bits_set (unsigned value, int p, int n, unsigned int y){ int intsize=int_size(); /the length of unsigned int/ if ( n &lt; 0 || p &lt; 0 || p + n &gt; intsize ) return 0; unsigned tar=bits_get(y,n-1,n); return (value &amp; ((~0 &lt;&lt; n) &lt;&lt; (p+1-n))) | tar;} 源文档http://www.cnblogs.com/xuqiang/archive/2010/02/12/1953759.html","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"转载","slug":"来源/转载","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E8%BD%AC%E8%BD%BD/"}]},{"title":"c、c++一些好的网站","slug":"language_c_cpp_common_goodsite","date":"2021-03-15T00:19:09.775Z","updated":"2021-03-16T13:59:54.896Z","comments":true,"path":"2021/03/15/language_c_cpp_common_goodsite/","link":"","permalink":"http://example.com/2021/03/15/language_c_cpp_common_goodsite/","excerpt":"","text":"https://www.coder.workhttps://www.keil.com/support/man/docs/armcc/armcc_chr1359124967692.htm","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"原创","slug":"来源/原创","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E5%8E%9F%E5%88%9B/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"原创","slug":"来源/原创","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E5%8E%9F%E5%88%9B/"}]},{"title":"上学的意义","slug":"life_child_1","date":"2021-03-15T00:13:38.489Z","updated":"2021-03-15T00:18:40.709Z","comments":true,"path":"2021/03/15/life_child_1/","link":"","permalink":"http://example.com/2021/03/15/life_child_1/","excerpt":"","text":"-上学为了学到更多的知识，而有的老师已经是为了上线而上学，把出勤率当成了目标 。","categories":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"上学的意义","slug":"生活/上学的意义","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E4%B8%8A%E5%AD%A6%E7%9A%84%E6%84%8F%E4%B9%89/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/"},{"name":"上学的意义","slug":"生活/上学的意义","permalink":"http://example.com/categories/%E7%94%9F%E6%B4%BB/%E4%B8%8A%E5%AD%A6%E7%9A%84%E6%84%8F%E4%B9%89/"}]},{"title":"inline(内联) 详解","slug":"language_c_cpp_keyword_inline","date":"2021-03-10T14:23:55.829Z","updated":"2021-03-16T13:59:09.853Z","comments":true,"path":"2021/03/10/language_c_cpp_keyword_inline/","link":"","permalink":"http://example.com/2021/03/10/language_c_cpp_keyword_inline/","excerpt":"","text":"几个关键字的关系 inline function_declarator;__inline function_declarator; // Microsoft相关__forceinline function_declarator; // Microsoft相关 __inline 与inline等同。inline和__inline通知编译器将该函数的内容拷贝一份放在调用函数的地方，这称之为内联。内联减少了函数调用的开销，但 却增加了代码量。 __forceinline关键字则是不基于编译器的性能和优化分析而依赖于程序员的判断进行内联，但它也不保证一定内敛，有些情况函数 是肯定不能内敛的。要慎用__forceinline，不加考虑的使用它将会造成代码量的膨胀而只得到很小的性能回报，甚至造成性能下降。(**在GCC和clang中还有__attribute__((always_inline))**。) inline关键字仅用于C++；__inline和__forceinline在C和C++中都可用。 static ， extern与inline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static inline 表示只会是当前模块才会调用这个内联函数；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;non-static inline 表示可能有其他模块会调用这个内联函数，别的模块也不能定义这个函数。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果函数定义中，同时指定inline和extern，该定义仅用于内联。函数也不会独自编译（因为已经被认为可能会被其他模块调用，会在每个调用处内联、编译） 阻止内联&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;阻止inline，可以使用函数属性 noinline 。即使使用了建议inline关键字修饰，noinline 也会阻止真正内联。attribute((noinline)) inline static int f(int a, int b){ return (a + b);} main(){ // .. f(1,2) ; // 该处函数不会真正内联} 在以下情况中，编译器不进行函数内联，即使是使用forceinline：__ 函数或其调用者使用/Ob0编译器选项进行编译(Debug模式下的默认选项)。也就是说在Debug模式下，是不会发生函数内联的。 当使用/clr编译器选项时，如果函数使用了安全属性，则不会进行内联。 注：公共语言运行时（CLR）是一套完整的、高级的虚拟机，它被设计为用来支持不同的编程语言，并支持它们之间的互操作。 函数具有可变数目的参数。 函数使用了在线汇编(即直接在你C/C++代码里加入汇编语言代码)。但使用了编译器关于优化的选项/Og，/Ox，/O1，或/O2的情况除外。 是虚函数并且是虚调用。但对虚函数的直接调用可以inline。 通过指向该函数的函数指针进行调用。 函数被关键字__declspec(naked)修饰。 需要注意的点&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？ 内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。 类的成员函数如果是在类定义的同时定义的，那么它默认是inline的，否则也可以使用inline指定为内联的。 例如class A{ public:void Foo(int x, int y) { } // 自动地成为内联函数}将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成：// 头文件class A{ public: void Foo(int x, int y);}// 定义文件inline void A::Foo(int x, int y){} 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如下风格的函数Foo 不能成为内联函数： inline void Foo(int x, int y); // inline 仅与函数声明放在一起 void Foo(int x, int y){} 而如下风格的函数Foo 则成为内联函数： void Foo(int x, int y); inline void Foo(int x, int y) // inline 与函数定义体放在一起{} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inline 函数对编译器而言必须是可见的，以便它能够在调用点内展开该函数。与非inline函数不同的是，inline函数必须在调用该函数的每个文本文件中定义。当然，对于同一程序的不同文件，如果inline函数出现的话，其定义必须相同。对于由两个文件compute.C和draw.C构成的程序来说，程序员不能定义这样的min()函数，它在compute.C中指一件事情，而在draw.C中指另外一件事情。如果两个定义不相同，程序将会有未定义的行为： 为保证不会发生这样的事情，建议把inline函数的定义放到头文件中。在每个调用该inline函数的文件中包含该头文件。这种方法保证对每个inline函数只有一个定义，且程序员无需复制代码，并且不可能在程序的生命期中引起无意的不匹配的事情。 如果函数使用了__forceinline关键字，但实际没有进行内联，将给出level 1警告。__ 可以通过使用.inl文件，把inline的源文件和头文件分开例如头文件定义在a.h ,定义的函数为int f(); 在a.inl 中实现inline int f() {}即可，然后再a.h的尾部include “a.inl” 以下情况不宜使用内联： 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了 inline 不应该出现在函数的声明中）。 那么如果一个函数被声明为inline但是却没有被内联将会发生什么呢？理论上，当编译器拒绝内联一个函数的时候，那个函数会像普通函数一样被对待，但是还会出现一些其他的问题。例如下面这段代码：// filename Time.h#include#includeusing namespace std;class Time{public: inline void Show() &#123; for (int i = 0; i&lt;10; i++) cout&lt;&lt;time(0)&lt;&lt;endl; &#125; }; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为成员函数Time::Show()包括一个局部变量和一个for循环，所以编译器一般拒绝inline，并且把它当作一个普通的成员函数。但是这个包含类声明的头文件会被单独的#include进各个独立的编译单元中： // filename f1.cpp #include “Time.h” void f1() { Time t1; t1.Show(); } // filename f2.cpp #include “Time.h” void f2() { Time t2; t2.Show(); } 结果编译器为这个程序生成了两个相同成员函数的拷贝： void f1(); void f2(); int main() { f1(); f2(); return 0; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当程序被链接的时候，linker将会面对两个相同的Time::Show()拷贝，于是函数重定义的连接错误发生。但是老一些的C++实现对付这种情况的办法是通过把一个un-inlined函数当作static来处理。因此每一份函数拷贝仅仅在自己的编译单元中可见，这样链接错误就解决了，但是在程序中却会留下多份函数拷贝。在这种情况下，程序的性能不但没有提升，反而增加了编译和链接时间以及最终可执行体的大小。但是幸运的是，新的C++标准中关于un-inlined函数的说法已经改变。一个符合标准C++实现应该只生成一份函数拷贝。然而，要想所有的编译器都支持这一点可能还需要很长时间。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;另外关于内联函数还有两个更令人头疼的问题。第一个问题是该如何进行维护。一个函数开始的时候可能以内联的形式出现，但是随着系统的扩展，函数体可能要求添加额外的功能，结果内联函数就变得不太可能，因此需要把inline specifier去除以及把函数体放到一个单独的源文件中。另一个问题是当内联函数被应用在代码库的时候产生。当内联函数改变的时候，用户必须重新编译他们的代码以反映这种改变。然而对于一个非内联函数，用户仅仅需要重新链接就可以了。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里想要说的是，内联函数并不是一个增强性能的灵丹妙药。只有当函数非常短小的时候它才能得到我们想要的效果，但是如果函数并不是很短而且在很多地方都被调用的话，那么将会使得可执行体的体积增大。最令人烦恼的还是当编译器拒绝内联的时候。在老的实现中，结果很不尽人意，虽然在新的实现中有很大的改善，但是仍然还是不那么完善的。一些编译器能够足够的聪明来指出哪些函数可以内联哪些不能，但是，大多数编译器就不那么聪明了，因此这就需要我们的经验来判断。如果内联函数不能增强行能，就避免使用它！ 用法1.inline__inline__是ISO C90的写法写法1inline int foo(int *a){ return (*a) ++;} 写法2inline foo(int *a); int foo(int *a){ return (*a) ++;} __attribute （（always_inline）） 或者_attribute ((gnu_inline))适用于gcc编译器（参考gcc 参考手册）inline void foo(int a) __attribute __（（always_inline））; 或者 __attribute __ ((always_inline）) void foo(int a); 如何判断是否内联？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过查看生成的汇编代码，比如.lst文件，assembly文件。函数调用往往包含入栈、出栈的操作（汇编指令），而内联函数没有这些。 参考文件https://www.keil.com/support/man/docs/armcc/armcc_chr1359124967692.htmhttps://www.coder.work/article/13148https://blog.csdn.net/nanhaizhixin/article/details/7564084https://developer.aliyun.com/article/384661https://www.cnblogs.com/fortunely/p/13430735.html","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"原创","slug":"来源/原创","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E5%8E%9F%E5%88%9B/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"},{"name":"来源","slug":"来源","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/"},{"name":"原创","slug":"来源/原创","permalink":"http://example.com/categories/%E6%9D%A5%E6%BA%90/%E5%8E%9F%E5%88%9B/"}]},{"title":"system_windows_desp","slug":"system-windows-desp","date":"2021-03-10T13:32:59.000Z","updated":"2021-03-10T13:32:59.555Z","comments":true,"path":"2021/03/10/system-windows-desp/","link":"","permalink":"http://example.com/2021/03/10/system-windows-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"system_linux_desp","slug":"system-linux-desp","date":"2021-03-10T13:32:42.000Z","updated":"2021-03-10T13:32:42.676Z","comments":true,"path":"2021/03/10/system-linux-desp/","link":"","permalink":"http://example.com/2021/03/10/system-linux-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"spider_desp","slug":"spider-desp","date":"2021-03-10T13:31:36.000Z","updated":"2021-03-10T13:31:36.638Z","comments":true,"path":"2021/03/10/spider-desp/","link":"","permalink":"http://example.com/2021/03/10/spider-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"language_java_desp","slug":"language-java-desp","date":"2021-03-10T13:30:56.000Z","updated":"2021-03-10T13:30:56.975Z","comments":true,"path":"2021/03/10/language-java-desp/","link":"","permalink":"http://example.com/2021/03/10/language-java-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"language_shell_desp","slug":"language-shell-desp","date":"2021-03-10T13:30:39.000Z","updated":"2021-03-10T13:30:39.596Z","comments":true,"path":"2021/03/10/language-shell-desp/","link":"","permalink":"http://example.com/2021/03/10/language-shell-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"language_python_desp","slug":"language-python-desp","date":"2021-03-10T13:30:29.000Z","updated":"2021-03-10T13:30:29.123Z","comments":true,"path":"2021/03/10/language-python-desp/","link":"","permalink":"http://example.com/2021/03/10/language-python-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"using namespace 和 using对比","slug":"language_c_cpp_keyword_using","date":"2021-03-10T13:29:02.060Z","updated":"2021-03-10T14:34:19.465Z","comments":true,"path":"2021/03/10/language_c_cpp_keyword_using/","link":"","permalink":"http://example.com/2021/03/10/language_c_cpp_keyword_using/","excerpt":"","text":"当使用 using namespace A::B::C之后 ,以后直接调用C内部的成员就行了，就不需要C了，这种方式是域内部公开。 using A::B::C, 与第一种相反，此处调用 C域下的函数时C域就不能省略了，所以当你使用C下的类或函数时，就需要 C::函数()形式; 例如C有成员函数f，当使用using namespace时，直接使用f即可，当使用using时，需要使用C::f 尽量不要写using namespace,因为随着项目的增大，会污染其他的文件，很难查出问题。因为使用using namespace，的话就没有起到命名空间的作用。再次回到了如同没有涉及命名空间时，所有标示符都定义在全局作用于中的混乱情况，不利于程序员创建新对象。 总结，感觉没有多大区别，前者使用方便，但对于查找函数或类的来源不好确定，而后者相对阅读来说好一点，而且不会污染其他文件，所以工程中，尽量使用using。","categories":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"c++&c语言","slug":"c-c语言","permalink":"http://example.com/tags/c-c%E8%AF%AD%E8%A8%80/"}],"keywords":[{"name":"语言","slug":"语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/"},{"name":"c++&c语言","slug":"语言/c-c语言","permalink":"http://example.com/categories/%E8%AF%AD%E8%A8%80/c-c%E8%AF%AD%E8%A8%80/"}]},{"title":"kv_leveldb_desp","slug":"kv-leveldb-desp","date":"2021-03-10T13:27:48.000Z","updated":"2021-03-10T13:27:48.092Z","comments":true,"path":"2021/03/10/kv-leveldb-desp/","link":"","permalink":"http://example.com/2021/03/10/kv-leveldb-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"kv_tera_desp","slug":"kv-tera-desp","date":"2021-03-10T13:27:15.000Z","updated":"2021-03-10T13:27:15.594Z","comments":true,"path":"2021/03/10/kv-tera-desp/","link":"","permalink":"http://example.com/2021/03/10/kv-tera-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"bigdata_beam_desp","slug":"bigdata-beam-desp","date":"2021-03-10T13:26:37.000Z","updated":"2021-03-10T13:26:37.457Z","comments":true,"path":"2021/03/10/bigdata-beam-desp/","link":"","permalink":"http://example.com/2021/03/10/bigdata-beam-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"bigdata_flink_desp","slug":"bigdata-flink-desp","date":"2021-03-10T13:26:19.000Z","updated":"2021-03-10T13:26:19.495Z","comments":true,"path":"2021/03/10/bigdata-flink-desp/","link":"","permalink":"http://example.com/2021/03/10/bigdata-flink-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"bigdata_hbase_desp","slug":"bigdata-hbase-desp","date":"2021-03-10T13:26:00.000Z","updated":"2021-03-10T13:26:00.733Z","comments":true,"path":"2021/03/10/bigdata-hbase-desp/","link":"","permalink":"http://example.com/2021/03/10/bigdata-hbase-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"常见问题","slug":"bigdata-hadoop-problem1","date":"2021-03-10T13:25:41.000Z","updated":"2021-03-15T14:18:52.012Z","comments":true,"path":"2021/03/10/bigdata-hadoop-problem1/","link":"","permalink":"http://example.com/2021/03/10/bigdata-hadoop-problem1/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"search_vector_milvus_desp","slug":"search-vector-milvus-desp","date":"2021-03-10T13:24:32.000Z","updated":"2021-03-10T13:24:32.656Z","comments":true,"path":"2021/03/10/search-vector-milvus-desp/","link":"","permalink":"http://example.com/2021/03/10/search-vector-milvus-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"search_vector_faiss_desp","slug":"search-vector-faiss-desp","date":"2021-03-10T13:22:36.000Z","updated":"2021-03-10T13:22:36.241Z","comments":true,"path":"2021/03/10/search-vector-faiss-desp/","link":"","permalink":"http://example.com/2021/03/10/search-vector-faiss-desp/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"management_desp","date":"2021-03-09T14:53:20.238Z","updated":"2021-03-09T14:54:05.092Z","comments":true,"path":"2021/03/09/management_desp/","link":"","permalink":"http://example.com/2021/03/09/management_desp/","excerpt":"","text":"title: management简介date: 2021-03-09 22:53:20","categories":[{"name":"management","slug":"management","permalink":"http://example.com/categories/management/"}],"tags":[{"name":"management","slug":"management","permalink":"http://example.com/tags/management/"}],"keywords":[{"name":"management","slug":"management","permalink":"http://example.com/categories/management/"}]},{"title":"","slug":"idea_desp","date":"2021-03-09T14:52:14.514Z","updated":"2021-03-09T14:54:58.074Z","comments":true,"path":"2021/03/09/idea_desp/","link":"","permalink":"http://example.com/2021/03/09/idea_desp/","excerpt":"","text":"title: idea简介date: 2021-03-09 22:52:14","categories":[{"name":"idea","slug":"idea","permalink":"http://example.com/categories/idea/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://example.com/tags/idea/"}],"keywords":[{"name":"idea","slug":"idea","permalink":"http://example.com/categories/idea/"}]},{"title":"","slug":"search_clucene_desp","date":"2021-03-09T13:45:41.005Z","updated":"2021-03-09T14:41:58.339Z","comments":true,"path":"2021/03/09/search_clucene_desp/","link":"","permalink":"http://example.com/2021/03/09/search_clucene_desp/","excerpt":"","text":"title: clucene简介date: 2021-03-09 21:45:40","categories":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"clucene","slug":"search/clucene","permalink":"http://example.com/categories/search/clucene/"}],"tags":[{"name":"clucene","slug":"clucene","permalink":"http://example.com/tags/clucene/"}],"keywords":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"clucene","slug":"search/clucene","permalink":"http://example.com/categories/search/clucene/"}]},{"title":"","slug":"search_xapian_desp","date":"2021-03-09T13:11:04.129Z","updated":"2021-03-09T14:47:16.063Z","comments":true,"path":"2021/03/09/search_xapian_desp/","link":"","permalink":"http://example.com/2021/03/09/search_xapian_desp/","excerpt":"","text":"title: xapian简介date: 2021-03-09 21:11:04","categories":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"sphinx","slug":"search/sphinx","permalink":"http://example.com/categories/search/sphinx/"}],"tags":[{"name":"sphinx","slug":"sphinx","permalink":"http://example.com/tags/sphinx/"}],"keywords":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"sphinx","slug":"search/sphinx","permalink":"http://example.com/categories/search/sphinx/"}]},{"title":"","slug":"serach_kingso_desp","date":"2021-03-09T13:08:55.794Z","updated":"2021-03-09T14:45:23.462Z","comments":true,"path":"2021/03/09/serach_kingso_desp/","link":"","permalink":"http://example.com/2021/03/09/serach_kingso_desp/","excerpt":"","text":"title: kingso简介date: 2021-03-09 21:08:55","categories":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"kingso","slug":"search/kingso","permalink":"http://example.com/categories/search/kingso/"}],"tags":[{"name":"kingso","slug":"kingso","permalink":"http://example.com/tags/kingso/"}],"keywords":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"kingso","slug":"search/kingso","permalink":"http://example.com/categories/search/kingso/"}]},{"title":"","slug":"search_elasticsearch_desp","date":"2021-03-09T13:08:13.210Z","updated":"2021-03-09T14:44:35.414Z","comments":true,"path":"2021/03/09/search_elasticsearch_desp/","link":"","permalink":"http://example.com/2021/03/09/search_elasticsearch_desp/","excerpt":"","text":"title: elasticsearch简介date: 2021-03-09 21:08:13","categories":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"elasticsearch","slug":"search/elasticsearch","permalink":"http://example.com/categories/search/elasticsearch/"}],"tags":[{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://example.com/tags/elasticsearch/"}],"keywords":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"elasticsearch","slug":"search/elasticsearch","permalink":"http://example.com/categories/search/elasticsearch/"}]},{"title":"","slug":"search_indextank_desp","date":"2021-03-09T13:06:37.281Z","updated":"2021-03-09T14:43:48.246Z","comments":true,"path":"2021/03/09/search_indextank_desp/","link":"","permalink":"http://example.com/2021/03/09/search_indextank_desp/","excerpt":"","text":"title: indextank简介date: 2021-03-09 21:06:37","categories":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"indextank","slug":"search/indextank","permalink":"http://example.com/categories/search/indextank/"}],"tags":[{"name":"indextank","slug":"indextank","permalink":"http://example.com/tags/indextank/"}],"keywords":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"indextank","slug":"search/indextank","permalink":"http://example.com/categories/search/indextank/"}]},{"title":"","slug":"serach_sphinx_desp","date":"2021-03-09T13:06:09.238Z","updated":"2021-03-09T14:47:05.777Z","comments":true,"path":"2021/03/09/serach_sphinx_desp/","link":"","permalink":"http://example.com/2021/03/09/serach_sphinx_desp/","excerpt":"","text":"title: sphinx简介date: 2021-03-09 21:06:09","categories":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"sphinx","slug":"search/sphinx","permalink":"http://example.com/categories/search/sphinx/"}],"tags":[{"name":"sphinx","slug":"sphinx","permalink":"http://example.com/tags/sphinx/"}],"keywords":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"sphinx","slug":"search/sphinx","permalink":"http://example.com/categories/search/sphinx/"}]},{"title":"","slug":"search_lucene_desp","date":"2021-03-09T13:05:50.958Z","updated":"2021-03-09T14:46:04.322Z","comments":true,"path":"2021/03/09/search_lucene_desp/","link":"","permalink":"http://example.com/2021/03/09/search_lucene_desp/","excerpt":"","text":"title: lucene简介date: 2021-03-09 21:05:50","categories":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"lucene","slug":"search/lucene","permalink":"http://example.com/categories/search/lucene/"}],"tags":[{"name":"lucene","slug":"lucene","permalink":"http://example.com/tags/lucene/"}],"keywords":[{"name":"search","slug":"search","permalink":"http://example.com/categories/search/"},{"name":"lucene","slug":"search/lucene","permalink":"http://example.com/categories/search/lucene/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-03-08T13:50:01.648Z","updated":"2021-03-09T14:31:19.275Z","comments":true,"path":"2021/03/08/hello-world/","link":"","permalink":"http://example.com/2021/03/08/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]}]}